ALL CODE IN PLAINTEXT
==================================================
Generated: 2025-09-16T05:24:31.603091


================================================================================
FILE: mm/ariadne.py
================================================================================
#===================================================================
# 🍁 A R I A N D E           bot version 6.1 file build 20250915.01
#===================================================================
# last update: 2025 | Sept. 15                  Production ready ✅
#===================================================================
# Ariadne Actual
# mm/ariadne.py
#
# Initialized: August 19, 2025
# Sim Testing: ---   
# Launched: ---
# KuCoin exchange market maker bot. 
# Initial capital of $2,500 CAD
#
# [520] [741] [8]
#===================================================================
# 🔰 THE COMMANDER            ✔ PERSISTANT RUNTIME  ✔ MONIT MANAGED
#===================================================================

# 🔸 Standard Library Imports ======================================

import os
import importlib
import smtplib
import ssl
import uuid
from datetime import datetime
from email.message import EmailMessage
from email.utils import formataddr
from zoneinfo import ZoneInfo

# 🔸 third-party imports ===========================================

from dotenv import load_dotenv

# 🔸 local application imports =====================================

import mm.config.marcus as marcus
from mm.core.calvin import DrCalvin
from mm.core.grayson import Grayson
from mm.core.quorra import Quorra
from mm.core.petra import Petra
from mm.core.helen import Helen
from mm.core.malcolm import Malcolm
from mm.core.julius import Julius
from mm.core.verity import Verity
from mm.core.lamar import Lamar
from mm.core.alec import Alec
from mm.utils.nexus_6.rachael import Replicant
from mm.utils.database import Database
from mm.utils.heartbeat import Heartbeat

# 🔸 load env for this process =====================================

load_dotenv("mm/data/secrets/.env")

# 🔸 Drop-in Emailer ===============================================

def send_email(subject: str, status: str, title: str, message: str) -> str:

    importlib.reload(marcus)
    if not bool(getattr(marcus, "ALERT_EMAIL_ENABLED", False)):
        return "disabled"
    if str(getattr(marcus, "ALERT_EMAIL_ENCRYPT", "SSL")).upper() != "SSL":
        return "Simple Mail Transfer Protocol not established. No conn."

    host = getattr(marcus, "ALERT_EMAIL_SMTP_SERVER", None)
    port = getattr(marcus, "ALERT_EMAIL_SMTP_PORT", None)
    recipient = getattr(marcus, "ALERT_EMAIL_RECIPIENT", None)

    USERCODE = "ARI"  # hardcode per file

    # ---- Edit Sender Info (per file) ----
    user = os.getenv(f"{USERCODE}_USR")
    pwd = os.getenv(f"{USERCODE}_PWD")
    sender_email = user
    sender_name = os.getenv(f"{USERCODE}_NAME")
    # -------------------------------------

    STATUS_COLORS = {
        "STATCON3": "#F1C232",
        "STATCON2": "#E69138",
        "STATCON1": "#CC0000",
        "SIGCON1":  "#FB6D8B",
        "OPSCON5":  "#F5F5F5",
        "OPSCON1":  "#990000",
    }
    status_text = str(status).upper()
    status_color = STATUS_COLORS.get(status_text, "#BE644C")

    msg = EmailMessage()
    domain = sender_email.split("@")[1] if "@" in sender_email else "hodlcorp.io"
    msg_id = f"<{uuid.uuid4()}@{domain}>"
    msg["Message-ID"] = msg_id
    msg["From"] = formataddr((sender_name, sender_email))
    msg["To"] = recipient
    msg["Subject"] = subject
    msg["X-Priority"] = "1"
    msg["X-MSMail-Priority"] = "High"
    msg["Importance"] = "High"

    now_tz = datetime.now(ZoneInfo("America/Toronto"))
    sent_str = now_tz.strftime("%Y-%m-%d %H:%M:%S America/Toronto")
    epoch_ms = int(now_tz.timestamp() * 1000)
    mid_clean = msg_id.strip("<>").split("@", 1)[0]

    html_body = f"""
<div style="font-family: monospace;">
  <table role="presentation" width="100%" height="20px" cellpadding="8px" cellspacing="0" border="0">
    <tbody><tr style="font-family: Georgia, 'Times New Roman', Times, serif;font-size:20px;font-weight:600;background-color:#333;">
      <td align="left" style="color:#EFEFEF;letter-spacing:12px;">INTCOMM</td>
      <td align="right" style="color:{status_color};letter-spacing:4px;">{status_text}</td>
    </tr>
    <tr width="100%" cellpadding="6px" style="font-family: Tahoma, Geneva, sans-serif;text-align:left;font-size:14px;font-weight:600;color:#333;">
      <td colspan="2">{title}</td>
    </tr>
    <tr width="100%" cellpadding="6px" style="font-family: Tahoma, Geneva, sans-serif;text-align:left;font-size:11px;font-weight:400;line-height:1.5;color:#333;">
      <td colspan="2">{message}</td>
    </tr>
    <tr width="100%" height="25px"><td colspan="2">&nbsp;</td></tr>
  </tbody></table>
  <table role="presentation" width="400px" height="20px" cellpadding="4" cellspacing="0" border="0" style="font-family: Tahoma, Geneva, sans-serif;">
    <tbody><tr style="background-color:#333;">
      <td colspan="2" style="color:#efefef;font-size:12px;font-weight:600;">DOCINT</td>
    </tr>
    <tr style="background-color:#E9E9E5;">
      <td width="30px" style="color:#333;font-size:10px;font-weight:600;">SENT</td>
      <td width="10px" style="color:#333;font-size:10px;font-weight:600;">→</td>
      <td style="color:#333;font-size:11px;font-weight:400;">{sent_str}</td>
    </tr>
    <tr style="background-color:#F2F2F0;">
      <td width="30px" style="color:#333;font-size:10px;font-weight:600;">EPOCH</td>
      <td width="10px" style="color:#333;font-size:10px;font-weight:600;">→</td>
      <td style="color:#333;font-size:11px;font-weight:400;">{epoch_ms} (ms since 1970/01/01 0:00 UTC)</td>
    </tr>
    <tr style="background-color:#E9E9E5;">
      <td width="30px" style="color:#333;font-size:10px;font-weight:600;">m.ID</td>
      <td width="10px" style="color:#333;font-size:10px;font-weight:600;">→</td>
      <td style="color:#333;font-size:11px;font-weight:400;">{mid_clean}</td>
    </tr>
  </tbody></table>
</div>
"""

    msg.add_alternative(html_body, subtype="html")
    ctx = ssl.create_default_context()
    with smtplib.SMTP_SSL(host, port, context=ctx, timeout=10) as s:
        if user and pwd:
            s.login(user, pwd)
        s.send_message(msg)

    return msg_id

# 🔸 Ariadne Class =================================================

class Ariadne:

    def __init__(self, inara, logger):
        self.inara = inara
        self.logger = logger
        self.client = None
        self.mode = None
        self.cycle_count = 0

    def run(self):

# 🔸 STARTUP =======================================================
        
        self.logger.info("Starting cycle...")
        self.mode = self.inara.get_mode()
        self.client = self.inara.get_trading_client()
        self.logger.info(f"Mode: {self.mode}, Client: {self.client}")

# 🔸 OPEN ORDERS RISK ASSESSMENT====================================
        
        current_orders = self.client.get_open_orders()

        for order in current_orders.copy():
            order_id = order["id"]

            grayson = Grayson(order)
            if not grayson.compliant():
                Alec.cancel_orders_for_pair(order)
                self.logger.info(f"Order {order_id} canceled by Grayson.")
                continue

            score = DrCalvin.score_pair(order)
            if score < 75:
                Alec.cancel_orders_for_pair(order)
                self.logger.info(f"Order {order_id} canceled by Dr. Calvin (score {score}).")
                continue

            risk_client = Quorra(order)
            score2 = risk_client.score_pair()
            if score2 >= 80:
                continue
            elif 70 <= score2 < 80:
                Replicant(order).process()
                current_orders.remove(order)
                continue
            else:
                Alec.cancel_orders_for_pair(order)
                self.logger.info(f"Order {order_id} canceled by Quorra (score {score2}).")
                continue

# 🔸 SELL CYCLE ====================================================
        
        petra = Petra(self.client)
        proposals = petra.prepare_sell_orders(Helen.get_positions())

        for proposal in proposals:
            response = Lamar.listen(proposal)
            if response == "expired":
                score = Quorra(proposal).score_pair()
                if score >= 95:
                    petra.resubmit(proposal)
            elif response == "denied":
                score = Quorra(proposal).score_pair()
                if score <= 75:
                    self.logger.warning(f"Proposal denied and below threshold: {proposal}")
            elif response == "approved":
                self.client.place_order(proposal)

# 🔸 BUY CYCLE =====================================================
        
        best_pairs = Helen.get_best_pairs()
        best_pairs = [p for p in best_pairs if Grayson(p).compliant()]
        scored_pairs = [(p, Quorra(p).score_pair()) for p in best_pairs]

        malcolm = Malcolm(self.client)
        buy_proposals = malcolm.prepare_buy_orders(scored_pairs)

        for proposal in buy_proposals:
            response = Lamar.listen(proposal)
            if response == "expired":
                score = Quorra(proposal).score_pair()
                if score >= 95:
                    malcolm.resubmit(proposal)
            elif response == "denied":
                score = Quorra(proposal).score_pair()
                if score <= 75:
                    self.logger.warning(f"Proposal denied and below threshold: {proposal}")
            elif response == "approved":
                self.client.place_order(proposal)
                Database.record_order(proposal)

# 🔸 HOUSEKEEPING CYCLE ============================================

        if self.mode == "simulation":
            Julius().sweep_stale_holds()
            Helen.sweep_stale_holds()

        Verity(self.client).scan()

        if self.cycle_count % 10 == 0:
            Database.save_state()

        if self.cycle_count % 6 == 0:  # ~ every 2 minutes if cycle ~20s
            Heartbeat.stamp()

        self.cycle_count += 1

================================================================================
FILE: mm/core/verity.py
================================================================================
#>> A R I A N D E v6
#>> last update: 2025 | Sept. 5
#>>
#>> Applied IO (Intelligence Officer) (Metrics)
#>> mm/core/verity.py
#>>
#>> Performance and risk metrics tracking
#>> Statistical analysis of trading operations
#>> Provides insights for optimization
#>>
#>> Auth'd -> Commander
#>>
#>> [520] [741] [8]      
#>>----------------------------------------------------------------

# Build|20250905.01

import logging
import time
import json
from typing import Dict, List, Optional, Any
from datetime import datetime, timedelta
from collections import defaultdict, deque

# ── Logger Setup ──────────────────────────────────────────────────────

logger = logging.getLogger(‘ariadne.metrics’)

class Verity:
“””
Tracks and analyzes all performance and risk metrics
“””

```
def __init__(self, history_limit: int = 10000):
    """
    Initialize metrics tracking
    
    Args:
        history_limit: Maximum data points to keep per metric
    """
    self.logger = logger
    self.history_limit = history_limit
    
    # Core metric storage
    self.metrics: Dict[str, deque] = defaultdict(lambda: deque(maxlen=history_limit))
    self.counters: Dict[str, int] = defaultdict(int)
    
    # Summary statistics cache
    self.stats_cache: Dict[str, Dict] = {}
    self.cache_timestamp: float = 0
    self.cache_ttl: float = 60  # 1 minute cache
    
    # Trading-specific metrics
    self.trades: List[Dict] = []
    self.daily_metrics: Dict[str, Dict] = defaultdict(dict)
    self.session_start: float = time.time()
    
def record_metric(self, name: str, value: float, timestamp: Optional[float] = None):
    """
    Record a metric data point
    
    Args:
        name: Metric name
        value: Metric value
        timestamp: Optional timestamp (defaults to now)
    """
    if timestamp is None:
        timestamp = time.time()
        
    self.metrics[name].append({
        'value': value,
        'timestamp': timestamp
    })
    
    # Invalidate cache
    self.stats_cache.pop(name, None)
    
def increment_counter(self, name: str, amount: int = 1):
    """
    Increment a counter metric
    
    Args:
        name: Counter name
        amount: Amount to increment
    """
    self.counters[name] += amount
    
def get_stats(self, metric_name: str, window_seconds: Optional[int] = None) -> Dict:
    """
    Get statistics for a metric
    
    Args:
        metric_name: Name of metric
        window_seconds: Optional time window (uses all data if None)
        
    Returns:
        Dict with min, max, avg, count, last
    """
    # Check cache first
    cache_key = f"{metric_name}_{window_seconds}"
    if cache_key in self.stats_cache and time.time() - self.cache_timestamp < self.cache_ttl:
        return self.stats_cache[cache_key]
    
    if metric_name not in self.metrics:
        return {
            'min': 0,
            'max': 0,
            'avg': 0,
            'count': 0,
            'last': 0,
            'std_dev': 0
        }
    
    data = list(self.metrics[metric_name])
    
    # Filter by time window if specified
    if window_seconds:
        cutoff = time.time() - window_seconds
        data = [d for d in data if d['timestamp'] > cutoff]
    
    if not data:
        return {
            'min': 0,
            'max': 0,
            'avg': 0,
            'count': 0,
            'last': 0,
            'std_dev': 0
        }
    
    values = [d['value'] for d in data]
    
    # Calculate standard deviation
    avg = sum(values) / len(values)
    variance = sum((x - avg) ** 2 for x in values) / len(values)
    std_dev = variance ** 0.5
    
    stats = {
        'min': min(values),
        'max': max(values),
        'avg': avg,
        'count': len(values),
        'last': values[-1],
        'std_dev': std_dev
    }
    
    # Cache result
    self.stats_cache[cache_key] = stats
    self.cache_timestamp = time.time()
    
    return stats

def record_trade(self, trade: Dict):
    """
    Record a completed trade
    
    Args:
        trade: Trade details dict
    """
    trade['timestamp'] = time.time()
    self.trades.append(trade)
    
    # Update counters
    self.increment_counter(f"trades_{trade['side']}")
    self.increment_counter("trades_total")
    
    # Record P&L if available
    if 'pnl' in trade:
        self.record_metric('trade_pnl', trade['pnl'])
        if trade['pnl'] > 0:
            self.increment_counter('winning_trades')
        else:
            self.increment_counter('losing_trades')

def get_performance_summary(self) -> Dict:
    """
    Get comprehensive performance summary
    
    Returns:
        Dict with performance metrics
    """
    # Calculate uptime
    uptime_seconds = time.time() - self.session_start
    uptime_hours = uptime_seconds / 3600
    
    # Trade statistics
    total_trades = self.counters['trades_total']
    winning_trades = self.counters['winning_trades']
    losing_trades = self.counters['losing_trades']
    
    win_rate = 0
    if total_trades > 0:
        win_rate = winning_trades / total_trades
    
    # P&L statistics
    pnl_stats = self.get_stats('trade_pnl')
    loop_stats = self.get_stats('loop_time')
    equity_stats = self.get_stats('total_equity')
    
    return {
        'uptime_hours': round(uptime_hours, 2),
        'total_trades': total_trades,
        'winning_trades': winning_trades,
        'losing_trades': losing_trades,
        'win_rate': round(win_rate, 3),
        'buy_orders': self.counters['trades_buy'],
        'sell_orders': self.counters['trades_sell'],
        'pnl': {
            'total': sum(t.get('pnl', 0) for t in self.trades),
            'average': pnl_stats['avg'],
            'best': pnl_stats['max'],
            'worst': pnl_stats['min']
        },
        'loop_performance': {
            'average_ms': round(loop_stats['avg'] * 1000, 1),
            'min_ms': round(loop_stats['min'] * 1000, 1),
            'max_ms': round(loop_stats['max'] * 1000, 1)
        },
        'equity': {
            'current': equity_stats['last'],
            'high': equity_stats['max'],
            'low': equity_stats['min']
        }
    }

def get_hourly_metrics(self, hours: int = 24) -> Dict[str, List]:
    """
    Get metrics aggregated by hour
    
    Args:
        hours: Number of hours to retrieve
        
    Returns:
        Dict of metric_name -> list of hourly values
    """
    hourly_data = defaultdict(list)
    cutoff = time.time() - (hours * 3600)
    
    for metric_name, data in self.metrics.items():
        # Group by hour
        hourly_buckets = defaultdict(list)
        
        for point in data:
            if point['timestamp'] > cutoff:
                hour = datetime.fromtimestamp(point['timestamp']).replace(
                    minute=0, second=0, microsecond=0
                )
                hourly_buckets[hour].append(point['value'])
        
        # Calculate hourly averages
        for hour in sorted(hourly_buckets.keys()):
            values = hourly_buckets[hour]
            hourly_data[metric_name].append({
                'hour': hour.isoformat(),
                'avg': sum(values) / len(values),
                'count': len(values)
            })
    
    return dict(hourly_data)

def log_performance_stats(self):
    """Log current performance statistics"""
    summary = self.get_performance_summary()
    
    self.logger.info(
        f"📊 Performance - "
        f"Uptime: {summary['uptime_hours']:.1f}h | "
        f"Trades: {summary['total_trades']} (Win: {summary['win_rate']:.1%}) | "
        f"P&L: ${summary['pnl']['total']:.2f} | "
        f"Loop: {summary['loop_performance']['average_ms']}ms"
    )

def export_metrics(self, filepath: str):
    """
    Export all metrics to JSON file
    
    Args:
        filepath: Output file path
    """
    try:
        export_data = {
            'timestamp': time.time(),
            'session_start': self.session_start,
            'counters': dict(self.counters),
            'summary': self.get_performance_summary(),
            'metrics': {}
        }
        
        # Convert deques to lists for JSON serialization
        for name, data in self.metrics.items():
            export_data['metrics'][name] = list(data)
        
        with open(filepath, 'w') as f:
            json.dump(export_data, f, indent=2)
            
        self.logger.info(f"Exported metrics to {filepath}")
        
    except Exception as e:
        self.logger.error(f"Failed to export metrics: {e}")

def reset_daily_metrics(self):
    """Reset daily tracking (call at UTC midnight)"""
    # Store yesterday's data
    yesterday = (datetime.utcnow() - timedelta(days=1)).strftime('%Y-%m-%d')
    self.daily_metrics[yesterday] = {
        'trades': self.counters['trades_total'],
        'pnl': sum(t.get('pnl', 0) for t in self.trades),
        'win_rate': self.counters['winning_trades'] / max(1, self.counters['trades_total'])
    }
    
    # Reset counters
    for key in ['trades_total', 'trades_buy', 'trades_sell', 'winning_trades', 'losing_trades']:
        self.counters[key] = 0
        
    # Clear today's trades
        cutoff = datetime.utcnow().replace(hour=0, minute=0, second=0).timestamp()
        self.trades = [t for t in self.trades if t['timestamp'] < cutoff]
        
        self.logger.info("Daily metrics reset completed")

================================================================================
FILE: mm/core/grayson.py
================================================================================
#>> A R I A N D E [v 6.1]
#>> last update: 2025 | Sept. 9                ❌ PRODUCTION READY
#>>
#>> Risk Manager
#>> mm/core/grayson.py  
#>>
#>> Analytical layer for market analysis and decision logic. 
#>>
#>> Auth'd -> Commander
#>>
#>> [520] [741] [8]        💫 PERSISTANT RUNTIME  ➰ MONIT MANAGED
#>>────────────────────────────────────────────────────────────────

# Build|20250909.01

import os
import json
import logging
from dataclasses import dataclass
from typing import Dict, Optional, Tuple

import psycopg2

from mm.config import marcus
from mm.conn.conn_kucoin import KucoinClient

# Inara mode helpers
try:
    from mm.utils.helpers.inara import current_mode, is_live_mode
except Exception:
    def current_mode() -> str:
        return getattr(marcus, "MODE", "simulation")
    def is_live_mode() -> bool:
        return current_mode() == "live"

DSN = os.getenv("PG_DSN", "dbname=ariadne user=postgres host=localhost")
logger = logging.getLogger("grayson")
logger.setLevel(logging.INFO)


@dataclass
class Caps:
    quote: str = getattr(marcus, "QUOTE_CURRENCY", "USDT")
    min_trade: float = getattr(marcus, "MIN_TRADE_SIZE", 10.0)
    max_per_pair: float = getattr(marcus, "MAX_EXPOSURE_PER_PAIR", 0.10)      # share of equity
    max_total: float = getattr(marcus, "MAX_TOTAL_EXPOSURE", 0.60)            # share of equity
    max_asset_pct: float = getattr(marcus, "MAX_ASSET_PCT", 0.10)             # share of portfolio per asset
    cap_margin: float = getattr(marcus, "CAP_MARGIN", 0.01)                   # tolerance band
    max_active_pairs: int = getattr(marcus, "MAX_ACTIVE_PAIRS", 10)
    daily_loss_limit: float = getattr(marcus, "DAILY_LOSS_LIMIT", 0.05)
    max_drawdown_pct: float = getattr(marcus, "MAX_DRAWDOWN_PCT", 0.10)


class Grayson:
    def __init__(self, client: Optional[KucoinClient] = None, cfg: Caps = Caps()):
        self.cfg = cfg
        self.client = client or KucoinClient()
        self.conn = psycopg2.connect(DSN)
        self.cur = self.conn.cursor()

        # Sticky debug for last decision reason (handy in logs/UI)
        self.last_reason: str = ""
        logger.info("Grayson online | mode=%s | quote=%s", current_mode(), self.cfg.quote)

    # ─────────────────────────── External API ───────────────────────────

    def can_trade_pair(self, symbol: str, total_equity: float, *, side: str = "buy",
                       notional: Optional[float] = None) -> bool:
        """Quick gate used by selection/loop. Sets self.last_reason."""
        mode = current_mode()
        if not self._mode_allows(side):
            self.last_reason = f"mode_block:{mode}:{side}"
            return False

        # Notional unknown? Use small probe via last price × some min size (treated as pass-through).
        if notional is None:
            px = self._last_price(symbol)
            if px <= 0:
                self.last_reason = "no_price"
                return False
            # Minimalistic notional (won't be used for enforcement except min_trade check)
            notional = px * max(0.0, float(getattr(marcus, "MIN_TRADE_SIZE", self.cfg.min_trade)) / max(px, 1e-9))

        if not self._min_trade_ok(notional):
            self.last_reason = "min_trade"
            return False

        # Load exposures
        pair_exp, tot_exp, active_pairs = self._exposures(symbol)

        # Per-pair limit (include proposed notional)
        per_cap = (self.cfg.max_per_pair + self.cfg.cap_margin) * max(1e-9, total_equity)
        if pair_exp + notional > per_cap:
            self.last_reason = f"per_pair_cap:{pair_exp + notional:.2f}>{per_cap:.2f}"
            return False

        # Total exposure limit
        tot_cap = (self.cfg.max_total + self.cfg.cap_margin) * max(1e-9, total_equity)
        if tot_exp + notional > tot_cap:
            self.last_reason = f"total_cap:{tot_exp + notional:.2f}>{tot_cap:.2f}"
            return False

        # Max active pairs (BUY only increases count if position/order absent)
        if side.lower() == "buy" and active_pairs >= self.cfg.max_active_pairs and pair_exp <= 0:
            self.last_reason = "max_active_pairs"
            return False

        self.last_reason = "ok"
        return True

    def check_risk_limits(self, total_equity: float) -> Dict[str, str]:
        """
        Global guard called from main loop.
        Returns: {"trading_allowed": bool, "reason": str}
        """
        mode = current_mode()
        if mode in ("halted", "maintenance"):
            return {"trading_allowed": False, "reason": f"mode:{mode}"}

        # Daily loss / drawdown checks (best-effort, fail-open if no data)
        if not self._daily_loss_ok(total_equity):
            return {"trading_allowed": False, "reason": "daily_loss_limit"}
        if not self._drawdown_ok(total_equity):
            return {"trading_allowed": False, "reason": "max_drawdown"}

        return {"trading_allowed": True, "reason": "ok"}

    def vet_risk(self, proposal_id: int, total_equity: Optional[float] = None) -> str:
        """
        Phase-1 vetting for Lamar: sets proposals.risk_vet ← 'approved'|'denied'
        Side-aware: BUY/Sell both go through the same rules; mode gates applied.
        """
        prop = self._fetch_proposal(proposal_id)
        if not prop:
            return "denied"

        # Mode gating first
        if not self._mode_allows(prop["side"]):
            self._set_vet(proposal_id, "risk_vet", "denied")
            self._route_log(proposal_id, "risk.denied", {"reason": "mode_gate", "mode": current_mode(), "side": prop["side"]})
            return "denied"

        # Determine notional and equity
        px = float(prop["price_intent"])
        sz = float(prop["size_intent"])
        notional = px * sz
        eq = float(total_equity if total_equity is not None else getattr(marcus, "INITIAL_CAPITAL", 1000.0))

        ok = self.can_trade_pair(prop["symbol"], eq, side=prop["side"], notional=notional)
        status = "approved" if ok else "denied"
        self._set_vet(proposal_id, "risk_vet", status)
        self._route_log(proposal_id, f"risk.{status}", {
            "symbol": prop["symbol"], "side": prop["side"],
            "notional": notional, "reason": self.last_reason
        })
        return status

    # ─────────────────────────── Internals ────────────────────────────

    def _mode_allows(self, side: str) -> bool:
        side = side.lower()
        m = current_mode()
        if m in ("halted", "maintenance"):
            return False
        if m == "drain" and side == "buy":
            return False
        return True

    def _min_trade_ok(self, notional: float) -> bool:
        try:
            return float(notional) >= float(self.cfg.min_trade)
        except Exception:
            return False

    def _fetch_proposal(self, pid: int) -> Optional[Dict]:
        self.cur.execute("""
            SELECT id, symbol, side, price_intent, size_intent
            FROM proposals
            WHERE id = %s
        """, (pid,))
        row = self.cur.fetchone()
        if not row:
            return None
        return dict(zip(("id","symbol","side","price_intent","size_intent"), row))

    def _set_vet(self, pid: int, col: str, status: str) -> None:
        try:
            self.cur.execute(f"UPDATE proposals SET {col} = %s WHERE id = %s", (status, pid))
            self.conn.commit()
        except Exception as e:
            self.conn.rollback()
            logger.warning("vet update failed (%s) p=%s: %s", col, pid, e)

    def _route_log(self, proposal_id: int, status: str, info: Dict) -> None:
        try:
            self.cur.execute("""
                INSERT INTO proposal_router_log (proposal_id, timestamp, status, details)
                VALUES (%s, NOW(), %s, %s)
            """, (proposal_id, status, json.dumps(info)))
            self.conn.commit()
        except Exception as e:
            self.conn.rollback()
            logger.warning("router log insert failed p=%s: %s", proposal_id, e)

    # ───────────── Exposure accounting (SIM vs LIVE) ─────────────

    def _exposures(self, symbol: str) -> Tuple[float, float, int]:
        """
        Returns (pair_exposure, total_exposure, active_pairs_count) in QUOTE terms.
        Exposure = (long position notional + open BUY orders notional). SELL orders don't increase exposure.
        """
        # Positions
        if is_live_mode():
            pos_map = self._live_positions_notional()
            ord_pair, ord_total = self._open_buy_orders_notional(live=True, symbol=symbol)
        else:
            pos_map = self._sim_positions_notional()
            ord_pair, ord_total = self._open_buy_orders_notional(live=False, symbol=symbol)

        pair_exp = pos_map.get(symbol, 0.0) + ord_pair
        tot_exp = sum(pos_map.values()) + ord_total

        # Active pairs = symbols with positive (position notional OR open orders notional)
        active_pairs = set([s for s, v in pos_map.items() if v > 0.0])
        if ord_pair > 0:
            active_pairs.add(symbol)
        return (pair_exp, tot_exp, len(active_pairs))

    def _sim_positions_notional(self) -> Dict[str, float]:
        self.cur.execute("SELECT symbol, COALESCE(qty,0)::numeric FROM sim_positions")
        out: Dict[str, float] = {}
        rows = self.cur.fetchall() or []
        for sym, qty in rows:
            q = float(qty or 0.0)
            if q <= 0:
                continue
            px = self._last_price(sym)
            if px > 0:
                out[sym] = q * px
        return out

    def _live_positions_notional(self) -> Dict[str, float]:
        # Minimal assumption: positions table with (symbol, qty) or (symbol, quantity)
        try:
            self.cur.execute("SELECT symbol, COALESCE(qty,0)::numeric FROM positions")
        except Exception:
            try:
                self.conn.rollback()
                self.cur.execute("SELECT symbol, COALESCE(quantity,0)::numeric FROM positions")
            except Exception:
                self.conn.rollback()
                return {}
        out: Dict[str, float] = {}
        for sym, qty in (self.cur.fetchall() or []):
            q = float(qty or 0.0)
            if q <= 0:
                continue
            px = self._last_price(sym)
            if px > 0:
                out[sym] = q * px
        return out

    def _open_buy_orders_notional(self, live: bool, symbol: str) -> Tuple[float, float]:
        table = "orders" if live else "sim_orders"
        # status may be 'open' or 'active'; include both
        try:
            self.cur.execute(f"""
                SELECT symbol, COALESCE(price,0)::numeric, COALESCE(size,0)::numeric
                FROM {table}
                WHERE (status = 'open' OR status = 'active') AND side = 'buy'
            """)
        except Exception:
            self.conn.rollback()
            return (0.0, 0.0)

        pair_sum = 0.0
        tot_sum = 0.0
        for sym, price, size in (self.cur.fetchall() or []):
            n = float(price or 0.0) * float(size or 0.0)
            tot_sum += n
            if str(sym).upper() == str(symbol).upper():
                pair_sum += n
        return (pair_sum, tot_sum)

    # ─────────────── Global loss / drawdown checks ───────────────

    def _daily_loss_ok(self, total_equity: float) -> bool:
        """
        Best-effort: check simulated or logged PnL for the current day.
        If unavailable, allow trading (fail-open).
        """
        try:
            # Try a risk_metrics table for 'daily_return' or 'daily_pnl'
            self.cur.execute("""
                SELECT metric, value
                FROM risk_metrics
                WHERE metric IN ('daily_return','daily_pnl')
                ORDER BY timestamp DESC
                LIMIT 1
            """)
            row = self.cur.fetchone()
            if not row:
                return True
            metric, value = row
            v = float(value or 0.0)
            if metric == "daily_return":
                return v >= -self.cfg.daily_loss_limit
            if metric == "daily_pnl":
                # Interpret as absolute loss cap against equity
                return (v / max(1e-9, total_equity)) >= -self.cfg.daily_loss_limit
            return True
        except Exception:
            self.conn.rollback()
            return True

    def _drawdown_ok(self, total_equity: float) -> bool:
        """
        Best-effort: check last recorded drawdown in risk_metrics or performance_metrics.
        Fail-open if not available.
        """
        try:
            self.cur.execute("""
                SELECT metric, value
                FROM risk_metrics
                WHERE metric IN ('max_drawdown','drawdown')
                ORDER BY timestamp DESC
                LIMIT 1
            """)
            row = self.cur.fetchone()
            if not row:
                return True
            metric, value = row
            dd = float(value or 0.0)
            # If already a fraction (0..1) use directly; if looks like %, normalize
            if dd > 1.5:  # treat as percent
                dd = dd / 100.0
            return dd <= self.cfg.max_drawdown_pct + self.cfg.cap_margin
        except Exception:
            self.conn.rollback()
            return True

    # ───────────────────── Market pricing helpers ─────────────────────

    def _last_price(self, symbol: str) -> float:
        try:
            p = float(self.client.last_trade_price(symbol) or 0.0)
            if p > 0:
                return p
            # Fallback: mid from best bid/ask
            bid = float(self.client.best_bid_price(symbol) or 0.0)
            ask = float(self.client.best_ask_price(symbol) or 0.0)
            if bid > 0 and ask > 0:
                return (bid + ask) / 2.0
            return 0.0
        except Exception:
            return 0.0

================================================================================
FILE: mm/core/christian.py
================================================================================
#===================================================================
# 🍁 A R I A N D E           bot version 6.1 file build 20250916.01
#===================================================================
# last update: 2025 | Sept. 16                  Production ready ❌
#===================================================================
# Christian
# mm/core/christian.py
#
# Stub implementation to prevent import errors.
# All methods are no-ops for simulation mode.
#
# [520] [741] [8]
#===================================================================
# 🔰 THE COMMANDER            ✖ PERSISTANT RUNTIME  ✖ MONIT MANAGED
#===================================================================

import logging

logger = logging.getLogger("ariadne.christian")

class Christian:
    """
    Accounting Manager - Stub Implementation
    
    This is a stub to prevent import errors. In simulation mode,
    all accounting is handled by other components. 
    """
    
    def __init__(self, client=None, config=None):
        self.client = client
        self.config = config
        logger.info("Christian (Accounting Manager) stub initialized")
    
    def record_trade(self, *args, **kwargs):
        """Record a completed trade - stub"""
        pass
    
    def record_fee(self, *args, **kwargs):
        """Record trading fees - stub"""
        pass
    
    def record_pnl(self, *args, **kwargs):
        """Record profit/loss - stub"""
        pass
    
    def get_ledger(self, *args, **kwargs):
        """Get accounting ledger - stub"""
        return {}
    
    def balance_books(self, *args, **kwargs):
        """Balance the books - stub"""
        return True
    
    def generate_report(self, *args, **kwargs):
        """Generate accounting report - stub"""
        return "Accounting report not available in simulation mode"
    
    def audit_positions(self, *args, **kwargs):
        """Audit current positions - stub"""
        return True
    
    def reconcile_balances(self, *args, **kwargs):
        """Reconcile balances - stub"""
        return True

================================================================================
FILE: mm/core/ash.py
================================================================================
#>> A R I A N D E v6
#>> last update: 2025 | Sept. 4
#>>
#>> ASH - Balance Cache Manager
#>> mm/core/ash.py
#>>
#>> Maintains real-time balance cache for Julius
#>> Updates every second from database and exchange
#>>
#>> Auth'd -> Commander
#>>
#>> [520] [741] [8]
#>>────────────────────────────────────────────────────────────────

# Build|20250904.01

import os
import sys
import json
import signal
import time
from typing import Dict, Any
from pathlib import Path
from decimal import Decimal
from dotenv import load_dotenv
import psycopg2
import psycopg2.extras

# Load environment variables
load_dotenv()

# Add parent directory to path
sys.path.append('/root/Echelon/valentrix')

from mm.utils.helpers.wintermute import (
    get_logger,
    now_pack,
    write_pid_file,
    cleanup_pid_file,
    get_db_connection,
    release_db_connection
)

from mm.conn.conn_kucoin import KucoinClient

# Fetch the current operating mode from Inara
def get_mode_safe() -> str: 
    try: 
        from mm.utils.helpers import inara 
        return inara.get_mode() 
    except Exception: 
        return "halted"

# Configuration
BALANCE_CACHE_PATH = "/root/Echelon/valentrix/mm/data/source/balances.json"
PID_FILE = "/root/Echelon/valentrix/mm/core/ash.pid"
LOG_FILE = "/root/Echelon/valentrix/mm/core/ash.log"
UPDATE_INTERVAL = 1  # seconds

# Global shutdown flag
shutdown_requested = False

# Logger
log = get_logger("ash", LOG_FILE)

# Signal handler
def signal_handler(signum, frame):
    global shutdown_requested
    log.info(f"[SHUTDOWN] Received signal {signum}")
    shutdown_requested = True

signal.signal(signal.SIGINT, signal_handler)
signal.signal(signal.SIGTERM, signal_handler)

class BalanceCache:
    def __init__(self):
        self.kucoin = KucoinClient()
        self.cycle_count = 0
    
    def get_simulation_balances(self) -> Dict:
        """Get balances from sim_balances table."""
        conn = get_db_connection()
        try:
            cur = conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor)
            
            # Get all balances
            cur.execute("""
                SELECT asset, available, hold, (available + hold) as total
                FROM sim_balances
                WHERE (available + hold) > 0
            """)
            balances = {}
            for row in cur.fetchall():
                balances[row['asset']] = {
                    'available': float(row['available']),
                    'hold': float(row['hold']),
                    'total': float(row['total'])
                }
            
            # Get current prices for assets
            asset_values = {}
            total_equity = 0.0
            
            for asset, bal in balances.items():
                if asset == 'USDT':
                    asset_values[asset] = {
                        'native': bal['total'],
                        'usdt_value': bal['total']
                    }
                    total_equity += bal['total']
                else:
                    # Get price from tickstick
                    symbol = f"{asset}-USDT"
                    cur.execute("""
                        SELECT last FROM tickstick 
                        WHERE symbol = %s 
                        ORDER BY timestamp DESC 
                        LIMIT 1
                    """, (symbol,))
                    price_row = cur.fetchone()
                    
                    if price_row and price_row['last']:
                        price = float(price_row['last'])
                        usdt_value = bal['total'] * price
                        asset_values[asset] = {
                            'native': bal['total'],
                            'usdt_value': usdt_value
                        }
                        total_equity += usdt_value
                    else:
                        asset_values[asset] = {
                            'native': bal['total'],
                            'usdt_value': 0.0
                        }
            
            cur.close()
            
            return {
                'balances': balances,
                'asset_values': asset_values,
                'total_equity': total_equity
            }
            
        finally:
            release_db_connection(conn)
    
    def get_live_balances(self) -> Dict:
        """Get balances from KuCoin exchange."""
        try:
            # Get account balances
            raw_balances = self.kucoin.get_account_balances_detailed()
            
            balances = {}
            asset_values = {}
            total_equity = 0.0
            
            for asset, bal_info in raw_balances.items():
                if bal_info['available'] > 0 or bal_info['hold'] > 0:
                    balances[asset] = {
                        'available': bal_info['available'],
                        'hold': bal_info['hold'],
                        'total': bal_info['available'] + bal_info['hold']
                    }
                    
                    if asset == 'USDT':
                        asset_values[asset] = {
                            'native': balances[asset]['total'],
                            'usdt_value': balances[asset]['total']
                        }
                        total_equity += balances[asset]['total']
                    else:
                        # Get current price
                        symbol = f"{asset}-USDT"
                        price = self.kucoin.last_trade_price(symbol)
                        
                        if price and price > 0:
                            usdt_value = balances[asset]['total'] * price
                            asset_values[asset] = {
                                'native': balances[asset]['total'],
                                'usdt_value': usdt_value
                            }
                            total_equity += usdt_value
                        else:
                            asset_values[asset] = {
                                'native': balances[asset]['total'],
                                'usdt_value': 0.0
                            }
            
            return {
                'balances': balances,
                'asset_values': asset_values,
                'total_equity': total_equity
            }
            
        except Exception as e:
            log.error(f"Failed to get live balances: {e}")
            return {
                'balances': {},
                'asset_values': {},
                'total_equity': 0.0
            }
    
    def update_cache(self):
        """Update balance cache file."""
        self.cycle_count += 1
        
        try:
            mode = get_mode()
            tp = now_pack()
            
            # Get balances based on mode
            if mode == 'simulation':
                sim_data = self.get_simulation_balances()
                live_data = {'balances': {}, 'asset_values': {}, 'total_equity': 0.0}
            else:  # live
                sim_data = self.get_simulation_balances()  # Still track sim for comparison
                live_data = self.get_live_balances()
            
            # Build cache structure
            cache = {
                'version': '1.0',
                'updated_at': tp.iso,
                'updated_epoch_ms': tp.epoch_ms,
                'current_mode': mode,
                'simulation': {
                    'balances': sim_data['balances'],
                    'asset_values': sim_data['asset_values'],
                    'total_equity': sim_data['total_equity']
                },
                'live': {
                    'balances': live_data['balances'],
                    'asset_values': live_data['asset_values'],
                    'total_equity': live_data['total_equity']
                }
            }
            
            # Write atomically
            Path(BALANCE_CACHE_PATH).parent.mkdir(parents=True, exist_ok=True)
            temp_path = f"{BALANCE_CACHE_PATH}.tmp"
            
            with open(temp_path, 'w') as f:
                json.dump(cache, f, indent=2, default=str)
            
            os.rename(temp_path, BALANCE_CACHE_PATH)
            
            if self.cycle_count % 60 == 0:  # Log every minute
                log.info(f"Cache updated - Mode: {mode}, Sim equity: ${sim_data['total_equity']:.2f}, Live equity: ${live_data['total_equity']:.2f}")
                
        except Exception as e:
            log.error(f"Failed to update cache: {e}")
    
    def update_heartbeat(self):
        """Update heartbeat in database."""
        try:
            conn = get_db_connection()
            cur = conn.cursor()
            cur.execute("""
                INSERT INTO heartbeats (process_name, last_heartbeat, status, pid, cycle_count)
                VALUES ('ash', NOW(), 'caching', %s, %s)
                ON CONFLICT (process_name)
                DO UPDATE SET 
                    last_heartbeat = NOW(),
                    status = 'caching',
                    pid = %s,
                    cycle_count = %s
            """, (os.getpid(), self.cycle_count, os.getpid(), self.cycle_count))
            conn.commit()
            cur.close()
            release_db_connection(conn)
        except Exception as e:
            log.error(f"Failed to update heartbeat: {e}")
    
    def run(self):
        """Main process loop."""
        log.info(f"[INIT] ASH starting - updating every {UPDATE_INTERVAL}s")
        
        while not shutdown_requested:
            start = time.time()
            
            self.update_cache()
            
            # Update heartbeat every 30 cycles
            if self.cycle_count % 30 == 0:
                self.update_heartbeat()
            
            # Sleep for remainder of interval
            elapsed = time.time() - start
            sleep_time = max(UPDATE_INTERVAL - elapsed, 0.1)
            time.sleep(sleep_time)
        
        log.info("[SHUTDOWN] ASH shutting down")

if __name__ == "__main__":
    try:
        write_pid_file(PID_FILE)
        cache = BalanceCache()
        cache.run()
    finally:
        cleanup_pid_file(PID_FILE)

================================================================================
FILE: mm/core/helen.py
================================================================================
#>> A R I A N D E [v 6.1]
#>> last update: 2025 | Sept. 9                ❌ PRODUCTION READY
#>>
#>> Inventory Manager
#>> mm/core/helen.py
#>>
#>> Ensures orders are legitimate assets we own. 
#>> Approves orders via the proposals table.
#>> Manages assets.
#>>
#>> Auth'd -> Commander
#>>
#>> [520] [741] [8]        💫 PERSISTANT RUNTIME  ➰ MONIT MANAGED  
#>>────────────────────────────────────────────────────────────────

# Build|20250909.01

import os
import json
import logging
from dataclasses import dataclass
from typing import Dict, Optional, Tuple

import psycopg2

from mm.config import marcus
from mm.conn.conn_kucoin import KucoinClient
from mm.utils.helpers.wintermute import parse_symbol  # expects "BTC-USDT" -> ("BTC","USDT")

# Inara (mode gating). Safe fallbacks if helpers not present/newer.
try:
    from mm.utils.helpers.inara import current_mode, is_live_mode
except Exception:
    def current_mode() -> str:
        return getattr(marcus, "MODE", "simulation")
    def is_live_mode() -> bool:
        return current_mode() == "live"

DSN = os.getenv("PG_DSN", "dbname=ariadne user=postgres host=localhost")

logger = logging.getLogger("helen")
logger.setLevel(logging.INFO)


@dataclass
class HelenCfg:
    quote: str = marcus.QUOTE_CURRENCY  # e.g., "USDT"


class Helen:
    """
    Responsibilities
      • Phase 1 (vet): set proposals.invt_vet ← 'approved' | 'denied' based on inventory.
      • Phase 2 (finalize for SELL):
          - SIM: reserve by incrementing sim_positions.hold.
          - LIVE: no-op (exchange reserves), optional availability recheck.
      • Interfaces for Petra:
          - link_asset_hold_to_order(...): no-op in LIVE, SIM just logs (reservation already done).
          - on_cancel(...): SIM releases reservation (decrement sim_positions.hold); LIVE no-op.

    Notes
      • No hold_id is ever written to proposals (by design).
      • We use proposal_id as correlation to compute/rescind reserved qty.
      • get_positions(): used by main bot to read current inventory.
    """

    def __init__(self, client: Optional[KucoinClient] = None, cfg: HelenCfg = HelenCfg()):
        self.cfg = cfg
        self.client = client or KucoinClient()
        self.conn = psycopg2.connect(DSN)
        self.cur = self.conn.cursor()
        logger.info("Helen ready | mode=%s | quote=%s", current_mode(), self.cfg.quote)

    # ───────────────────────── Public API ─────────────────────────

    def get_positions(self) -> Dict[str, float]:
        """Return dict of { 'BTC-USDT': available_qty, ... }.
        SIM → from sim_positions (qty - hold); LIVE → from exchange balances (base assets)."""
        if is_live_mode():
            bals = self.client.get_account_balances_detailed()  # { 'BTC': {'available': x, 'hold': y}, ... }
            out: Dict[str, float] = {}
            for cur, v in (bals or {}).items():
                if cur == self.cfg.quote:
                    continue
                sym = f"{cur}-{self.cfg.quote}"
                out[sym] = float(v.get("available", 0.0))
            return out
        else:
            self.cur.execute("SELECT symbol, COALESCE(qty,0)::numeric, COALESCE(hold,0)::numeric FROM sim_positions")
            out: Dict[str, float] = {}
            for symbol, qty, hold in self.cur.fetchall():
                try:
                    avail = float(qty) - float(hold)
                except Exception:
                    avail = 0.0
                if avail > 0:
                    out[symbol] = avail
            return out

    def vet_inventory(self, proposal_id: int) -> str:
        """Phase 1: set invt_vet = 'approved' or 'denied' for SELL proposal."""
        prop = self._fetch_proposal(proposal_id)
        if not prop or prop["side"] != "sell":
            return "denied"

        ok = self._has_inventory(prop["symbol"], float(prop["size_intent"]))
        status = "approved" if ok else "denied"

        self.cur.execute("UPDATE proposals SET invt_vet = %s WHERE id = %s", (status, proposal_id))
        self.conn.commit()
        self._route_log(proposal_id, f"invt_vet.{status}", {"symbol": prop["symbol"], "size": float(prop["size_intent"])})
        return status

    def finalize_for_sell(self, proposal_id: int) -> bool:
        """
        Phase 2 for Petra-originated proposals: after Lamar sees all vets approved,
        he calls Helen to reserve inventory before signaling Petra.
        SIM: increment sim_positions.hold; LIVE: no DB hold (exchange will reserve at order).
        Returns True if reserved/validated OK.
        """
        prop = self._fetch_proposal(proposal_id, for_finalize=True)
        if not prop or prop["side"] != "sell":
            self._route_log(proposal_id, "invt_finalize.failed", {"reason": "not_found_or_wrong_side"})
            return False

        symbol = prop["symbol"]
        size = float(prop["size_intent"])

        if is_live_mode():
            # Re-validate availability on exchange
            if not self._has_inventory(symbol, size):
                self._route_log(proposal_id, "invt_finalize.denied", {"reason": "insufficient_live_bal"})
                return False
            # Optional: set status=approved here or let Lamar do it; we only log.
            self._route_log(proposal_id, "invt_finalize.live_ok", {"symbol": symbol, "size": size})
            return True

        # SIM mode: place a reservation by bumping sim_positions.hold atomically
        base, _ = parse_symbol(symbol)
        if not self._reserve_sim(symbol, size):
            self._route_log(proposal_id, "invt_finalize.denied", {"reason": "insufficient_sim_bal"})
            return False

        # Optional: status update to 'approved' can be Lamar's responsibility; keep idempotent if present.
        try:
            self.cur.execute("UPDATE proposals SET status='approved' WHERE id=%s", (proposal_id,))
            self.conn.commit()
        except Exception:
            self.conn.rollback()
        self._route_log(proposal_id, "invt_finalize.approved", {"symbol": symbol, "size": size})
        return True

    # Called by Petra after successful order placement
    def link_asset_hold_to_order(self, hold_id: Optional[str] = None, order_id: Optional[str] = None,
                                 correlation_id: Optional[str] = None) -> None:
        """
        SIM: reservation was already made; just log the linkage.
        LIVE: exchange manages reservation; just log.
        Supports both legacy signature (hold_id, order_id) and correlation_id="proposal:{id}".
        """
        info = {"hold_id": hold_id, "order_id": order_id, "correlation_id": correlation_id}
        pid = self._pid_from_corr(correlation_id)
        if pid:
            self._route_log(pid, "invt_linked", info)
        else:
            logger.info("Helen link (no pid): %s", info)

    # Called by Petra on placement failure to unwind a SIM reservation
    def on_cancel(self, order_id: Optional[str] = None, reason: str = "placement_failed",
                  correlation_id: Optional[str] = None) -> None:
        pid = self._pid_from_corr(correlation_id)
        prop = self._fetch_proposal(pid) if pid else None
        if not prop or prop["side"] != "sell":
            self._route_log(pid or -1, "invt_cancel.ignored", {"reason": "no_sell_proposal", "order_id": order_id})
            return

        symbol = prop["symbol"]
        size = float(prop["size_intent"])

        if not is_live_mode():
            self._release_sim(symbol, size)

        # Mark proposal failed (idempotent)
        try:
            self.cur.execute("UPDATE proposals SET status='failed' WHERE id=%s", (pid,))
            self.conn.commit()
        except Exception:
            self.conn.rollback()

        self._route_log(pid, "invt_cancel", {"order_id": order_id, "reason": reason, "symbol": symbol, "size": size})

    # ───────────────────────── Internals ─────────────────────────

    def _fetch_proposal(self, pid: Optional[int], for_finalize: bool = False) -> Optional[Dict]:
        if not pid:
            return None
        if for_finalize:
            # ensure all vets are approved (risk/bank/invt)
            self.cur.execute("""
                SELECT id, symbol, side, price_intent, size_intent, risk_vet, bank_vet, invt_vet
                FROM proposals WHERE id=%s
            """, (pid,))
            row = self.cur.fetchone()
            if not row:
                return None
            d = dict(zip(
                ("id","symbol","side","price_intent","size_intent","risk_vet","bank_vet","invt_vet"), row
            ))
            if (d.get("risk_vet") != "approved") or (d.get("bank_vet") != "approved") or (d.get("invt_vet") != "approved"):
                return None
            return d
        else:
            self.cur.execute("""
                SELECT id, symbol, side, price_intent, size_intent
                FROM proposals WHERE id=%s
            """, (pid,))
            row = self.cur.fetchone()
            return dict(zip(("id","symbol","side","price_intent","size_intent"), row)) if row else None

    def _has_inventory(self, symbol: str, size: float) -> bool:
        """Check available inventory for SELL."""
        base, quote = parse_symbol(symbol)

        if is_live_mode():
            bals = self.client.get_account_balances_detailed()  # LIVE balances per currency
            have = float((bals.get(base) or {}).get("available", 0.0))
            return have >= size

        # SIM: available = qty - hold
        self.cur.execute("SELECT COALESCE(qty,0)::numeric, COALESCE(hold,0)::numeric FROM sim_positions WHERE symbol=%s", (symbol,))
        row = self.cur.fetchone()
        if not row:
            return False
        qty, hold = [float(x or 0.0) for x in row]
        return (qty - hold) >= size

    def _reserve_sim(self, symbol: str, size: float) -> bool:
        """Atomically reserve inventory in SIM by bumping hold; ensure no negative available."""
        # Try optimistic update guarded by availability check in one statement
        self.cur.execute("""
            UPDATE sim_positions
               SET hold = hold + %s
             WHERE symbol = %s
               AND (COALESCE(qty,0) - COALESCE(hold,0)) >= %s
            RETURNING hold
        """, (size, symbol, size))
        ok = self.cur.fetchone() is not None
        if ok:
            self.conn.commit()
        else:
            self.conn.rollback()
        return ok

    def _release_sim(self, symbol: str, size: float) -> None:
        """Release a previous reservation in SIM (best-effort; never go below zero)."""
        self.cur.execute("""
            UPDATE sim_positions
               SET hold = GREATEST(0, COALESCE(hold,0) - %s)
             WHERE symbol = %s
        """, (size, symbol))
        self.conn.commit()

    def _route_log(self, proposal_id: int, status: str, info: Dict) -> None:
        """Append to proposal_router_log for observability."""
        try:
            self.cur.execute("""
                INSERT INTO proposal_router_log (proposal_id, timestamp, status, details)
                VALUES (%s, NOW(), %s, %s)
            """, (proposal_id, status, json.dumps(info)))
            self.conn.commit()
        except Exception as e:
            self.conn.rollback()
            logger.warning("router log insert failed p=%s: %s", proposal_id, e)

    @staticmethod
    def _pid_from_corr(correlation_id: Optional[str]) -> Optional[int]:
        """Parse 'proposal:{id}' → id."""
        if not correlation_id:
            return None
        s = str(correlation_id).strip()
        if s.startswith("proposal:"):
            try:
                return int(s.split(":", 1)[1])
            except Exception:
                return None
        return None

================================================================================
FILE: mm/core/alec.py
================================================================================
#>> A R I A N D E v6
#>> last update: 2025 | Sept. 5
#>>
#>> CANCELLATION MANAGER
#>> mm/core/alec.py
#>>
#>> Responsible for cancelling orders  
#>> Monitors for stale orders and stagnant pricing    
#>> Enforces compliance with configuration parameters
#>>
#>> Auth'd -> Commander
#>>
#>> [520] [741] [8]      
#>>────────────────────────────────────────────────────────────────

# Build|20250905.01

import logging
import time
from typing import Dict, List, Tuple, Optional
from datetime import datetime, timedelta

# Import config parameters
from mm.config.marcus import (
    ORDER_REFRESH_SECONDS, STALE_ORDER_HOURS,
    MAX_SPREAD_DRIFT_PCT, PRICE_STAGNANT_MINUTES,
    ALERT_EMAIL_ENABLED, ALERT_EMAIL_ADDRESS,
    ALERT_EMAIL_RECIPIENT, QUOTE_CURRENCY
)

# Email imports (conditional)
if ALERT_EMAIL_ENABLED:
    import smtplib
    from email.mime.text import MIMEText
    from mm.utils.helpers.timezone import get_email_date

# ── Logger Setup ──────────────────────────────────────────────────────
logger = logging.getLogger('ariadne.termination')

class Alec:
    """
    Manages order cancellations based on various criteria
    """
    
    def __init__(self, trading_client):
        """
        Initialize with trading client reference
        
        Args:
            trading_client: Either KucoinClient or SimClient
        """
        self.client = trading_client
        self.logger = logger
        self.order_history: Dict[str, Dict] = {}  # order_id -> order details
        self.price_history: Dict[str, List[Tuple[float, float]]] = {}  # symbol -> [(timestamp, price)]
        self.cancellation_stats: Dict[str, int] = {
            'stale': 0,
            'stagnant': 0,
            'drift': 0,
            'risk': 0,
            'manual': 0
        }
        
    def cancel_stale_orders(self) -> List[Tuple[str, str]]:
        """
        Cancel orders that are too old or need repricing
        
        Returns:
            List of (order_id, reason) tuples for cancelled orders
        """
        cancelled = []
        
        try:
            # Get all active orders
            all_orders = self.client.get_orders(status='active')
            
            for order in all_orders:
                order_id = order.get('id')
                symbol = order.get('symbol')
                
                # Check various cancellation criteria
                cancel_reason = self._should_cancel_order(order)
                
                if cancel_reason:
                    success = self._cancel_order(order_id, symbol)
                    if success:
                        cancelled.append((order_id, cancel_reason))
                        self.cancellation_stats[self._categorize_reason(cancel_reason)] += 1
                        
                # Update order tracking
                self.order_history[order_id] = {
                    'symbol': symbol,
                    'side': order.get('side'),
                    'price': float(order.get('price', 0)),
                    'size': float(order.get('size', 0)),
                    'created_at': order.get('createdAt', time.time()),
                    'last_checked': time.time()
                }
                
        except Exception as e:
            self.logger.error(f"Failed to check stale orders: {e}")
            
        if cancelled:
            self.logger.info(f"Cancelled {len(cancelled)} stale orders")
            
        return cancelled
    
    def cancel_all_orders(self) -> int:
        """
        Emergency cancel all open orders
        
        Returns:
            Number of orders cancelled
        """
        cancelled_count = 0
        
        try:
            all_orders = self.client.get_orders(status='active')
            
            self.logger.warning(f"EMERGENCY: Cancelling all {len(all_orders)} open orders")
            
            for order in all_orders:
                order_id = order.get('id')
                symbol = order.get('symbol')
                
                if self._cancel_order(order_id, symbol):
                    cancelled_count += 1
                    
            self._send_alert(f"Emergency cancelled {cancelled_count} orders")
            
        except Exception as e:
            self.logger.error(f"Failed to cancel all orders: {e}")
            self._send_alert(f"FAILED to cancel all orders: {e}")
            
        return cancelled_count
    
    def cancel_orders_for_pair(self, symbol: str, reason: str = "Manual request") -> int:
        """
        Cancel all orders for a specific trading pair
        
        Args:
            symbol: Trading pair symbol
            reason: Cancellation reason
            
        Returns:
            Number of orders cancelled
        """
        cancelled_count = 0
        
        try:
            orders = self.client.get_orders(symbol=symbol, status='active')
            
            for order in orders:
                order_id = order.get('id')
                if self._cancel_order(order_id, symbol):
                    cancelled_count += 1
                    
            if cancelled_count > 0:
                self.logger.info(f"Cancelled {cancelled_count} orders for {symbol}: {reason}")
                
        except Exception as e:
            self.logger.error(f"Failed to cancel orders for {symbol}: {e}")
            
        return cancelled_count
    
    def cleanup_old_positions(self, positions: Dict[str, float], 
                            hold_hours: int = 24) -> List[str]:
        """
        Identify positions held too long
        
        Args:
            positions: Current positions
            hold_hours: Maximum hold time
            
        Returns:
            List of symbols that should be liquidated
        """
        old_positions = []
        
        # This would need integration with trade history
        # For now, returning empty list
        # TODO: Track position entry times
        
        return old_positions
    
    def _should_cancel_order(self, order: Dict) -> Optional[str]:
        """
        Determine if an order should be cancelled
        
        Args:
            order: Order details
            
        Returns:
            Cancellation reason or None
        """
        order_id = order.get('id')
        symbol = order.get('symbol')
        created_at = order.get('createdAt', 0)
        price = float(order.get('price', 0))
        side = order.get('side')
        
        # Check if order is too old
        if created_at > 0:
            age_seconds = time.time() - (created_at / 1000)  # Convert ms to seconds
            if age_seconds > ORDER_REFRESH_SECONDS:
                return f"stale - {age_seconds/3600:.1f} hours old"
        
        # Check for price drift
        current_market = self._get_current_market(symbol)
        if current_market:
            mid_price = (current_market['bid'] + current_market['ask']) / 2
            
            if mid_price > 0:
                if side == 'buy':
                    # Buy order should be below mid
                    expected_price = mid_price * 0.995  # Rough estimate
                    drift = abs(price - expected_price) / expected_price
                else:
                    # Sell order should be above mid
                    expected_price = mid_price * 1.005
                    drift = abs(price - expected_price) / expected_price
                
                if drift > MAX_SPREAD_DRIFT_PCT:
                    return f"drift - {drift:.1%} from optimal"
        
        # Check for stagnant prices
        if self._is_price_stagnant(symbol):
            return "stagnant - price not moving"
        
        return None
    
    def _cancel_order(self, order_id: str, symbol: str) -> bool:
        """
        Execute order cancellation
        
        Args:
            order_id: Order ID to cancel
            symbol: Trading pair symbol
            
        Returns:
            True if successful
        """
        try:
            self.client.cancel_order(order_id)
            self.logger.debug(f"Cancelled order {order_id} for {symbol}")
            
            # Remove from tracking
            if order_id in self.order_history:
                del self.order_history[order_id]
                
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to cancel order {order_id}: {e}")
            return False
    
    def _get_current_market(self, symbol: str) -> Optional[Dict]:
        """
        Get current market data for symbol
        
        Args:
            symbol: Trading pair symbol
            
        Returns:
            Market data dict or None
        """
        try:
            tickers = self.client.get_ticker()
            for ticker in tickers:
                if ticker.get('symbol') == symbol:
                    return {
                        'bid': float(ticker.get('buy', 0)),
                        'ask': float(ticker.get('sell', 0)),
                        'last': float(ticker.get('last', 0))
                    }
        except Exception as e:
            self.logger.error(f"Failed to get market data: {e}")
            
        return None
    
    def _is_price_stagnant(self, symbol: str) -> bool:
        """
        Check if price has been stagnant
        
        Args:
            symbol: Trading pair symbol
            
        Returns:
            True if price is stagnant
        """
        if symbol not in self.price_history:
            return False
            
        history = self.price_history[symbol]
        if len(history) < 10:
            return False
            
        # Check price movement over last N minutes
        cutoff = time.time() - (PRICE_STAGNANT_MINUTES * 60)
        recent_prices = [price for ts, price in history if ts > cutoff]
        
        if len(recent_prices) < 2:
            return False
            
        # Calculate price range
        price_range = max(recent_prices) - min(recent_prices)
        avg_price = sum(recent_prices) / len(recent_prices)
        
        if avg_price > 0:
            volatility = price_range / avg_price
            # Consider stagnant if less than 0.1% movement
            return volatility < 0.001
            
        return False
    
    def update_price_tracking(self, symbol: str, price: float):
        """
        Update price history for stagnation detection
        
        Args:
            symbol: Trading pair symbol
            price: Current price
        """
        if symbol not in self.price_history:
            self.price_history[symbol] = []
            
        self.price_history[symbol].append((time.time(), price))
        
        # Keep only last hour
        cutoff = time.time() - 3600
        self.price_history[symbol] = [
            (ts, p) for ts, p in self.price_history[symbol] if ts > cutoff
        ]
    
    def get_cancellation_report(self) -> Dict:
        """
        Get cancellation statistics
        
        Returns:
            Dict with cancellation metrics
        """
        total_cancellations = sum(self.cancellation_stats.values())
        
        return {
            'total_cancellations': total_cancellations,
            'by_reason': self.cancellation_stats.copy(),
            'tracked_orders': len(self.order_history),
            'monitored_symbols': len(self.price_history),
            'oldest_order_age': self._get_oldest_order_age()
        }
    
    def _get_oldest_order_age(self) -> float:
        """Get age of oldest tracked order in hours"""
        if not self.order_history:
            return 0
            
        oldest = min(o['created_at'] for o in self.order_history.values())
        return (time.time() - oldest) / 3600
    
    def _categorize_reason(self, reason: str) -> str:
        """Categorize cancellation reason for stats"""
        if 'stale' in reason:
            return 'stale'
        elif 'drift' in reason:
            return 'drift'
        elif 'stagnant' in reason:
            return 'stagnant'
        elif 'risk' in reason.lower():
            return 'risk'
        else:
            return 'manual'
    
    def _send_alert(self, message: str):
        """
        Send email alert
        
        Args:
            message: Alert message
        """
        if not ALERT_EMAIL_ENABLED:
            return
            
        try:
            msg = MIMEText(message)
            msg['Subject'] = f"❌ Termination Officer Alert - {get_email_date()}"
            msg['From'] = ALERT_EMAIL_ADDRESS
            msg['To'] = ALERT_EMAIL_RECIPIENT
            msg['Date'] = get_email_date()
            
            server = smtplib.SMTP_SSL(ALERT_EMAIL_SMTP_SERVER, ALERT_EMAIL_SMTP_PORT)
            server.login(ALERT_EMAIL_ADDRESS, ALERT_EMAIL_PASSWORD)
            server.sendmail(ALERT_EMAIL_ADDRESS, [ALERT_EMAIL_RECIPIENT], msg.as_string())
            server.quit()
            
            self.logger.info("Alert email sent")
        except Exception as e:
            self.logger.error(f"Failed to send alert email: {e}")

================================================================================
FILE: mm/core/malcolm.py
================================================================================
#>> A R I A N D E [v 6.1]
#>> last update: 2025 | Sept. 9                ❌ PRODUCTION READY
#>>
#>> Purchasing Manager
#>> mm/core/malcolm.py
#>>
#>> Responsible for entering buy orders 
#>> Accepts filtered pairs from Dr. Calvin
#>> Honors balances and risk thresholds
#>>
#>> Auth'd -> Commander
#>>
#>> [520] [741] [8]        💫 PERSISTANT RUNTIME  ➰ MONIT MANAGED
#>>----------------------------------------------------------------

# Build|20250909.01

import os
import json
import time
import select
import signal
import pathlib
import logging
import logging.handlers
from dataclasses import dataclass
from typing import Optional, Dict, Any

import psycopg2

from mm.config import marcus
from mm.core.grayson import Grayson
from mm.core.julius import Julius
from mm.conn.conn_kucoin import KucoinClient
from mm.utils.tqt import andi

# Inara helpers (fallbacks keep Malcolm runnable if inara.py is older)
try:
    from mm.utils.helpers.inara import current_mode, can_place_orders, is_live_mode
except Exception:
    def current_mode() -> str:
        return getattr(marcus, "MODE", "simulation")
    def can_place_orders() -> bool:
        return current_mode() in ("live", "simulation", "shadow")
    def is_live_mode() -> bool:
        return current_mode() == "live"

# ────────────────────────── Config / Paths ────────────────────────────
DSN = os.getenv("PG_DSN", "dbname=ariadne user=postgres host=localhost")
CHANNEL_READY  = "proposals.ready.malcolm"
CHANNEL_DENIED = "proposals.denied.malcolm"
PROCESS_NAME   = "malcolm"

LOG_PATH = pathlib.Path("mm/logs/malcolm.log")
PID_PATH = pathlib.Path("mm/utils/soc/malcolm.pid")

HEARTBEAT_SEC = 5
LOOP_SLEEP    = 0.25

logger = logging.getLogger("malcolm")
logger.setLevel(logging.INFO)

def _setup_logging():
    LOG_PATH.parent.mkdir(parents=True, exist_ok=True)
    fh = logging.handlers.RotatingFileHandler(LOG_PATH, maxBytes=5_000_000, backupCount=3)
    fh.setFormatter(logging.Formatter('[%(asctime)s] %(levelname)s %(message)s'))
    logger.addHandler(fh)
    ch = logging.StreamHandler()
    ch.setFormatter(logging.Formatter('%(message)s'))
    logger.addHandler(ch)

def _write_pid():
    PID_PATH.parent.mkdir(parents=True, exist_ok=True)
    PID_PATH.write_text(str(os.getpid()))

@dataclass
class MalcolmCfg:
    quote: str = marcus.QUOTE_CURRENCY
    min_trade: float = getattr(marcus, "MIN_TRADE_SIZE", 10.0)

class Malcolm:
    """
    BUY Originator:
      - Maintains two DB connections (LISTEN vs ops)
      - Reacts to proposals.ready.malcolm / proposals.denied.malcolm
      - On READY: place limit order (mode-gated); link/unwind holds via Julius (sim), queue to Andi
      - On DENIED/EXPIRED: log and stop progression
      - Generates lightweight buy proposals opportunistically (stub; DrCalvin usually drives)
    """

    def __init__(self, client: Optional[KucoinClient] = None, cfg: MalcolmCfg = MalcolmCfg()):
        _setup_logging()
        _write_pid()

        self.cfg = cfg
        self.client = client or KucoinClient()
        self.julius = Julius(self.client)
        self.grayson = Grayson()

        # LISTEN connection (autocommit ON)
        self.listen_conn = psycopg2.connect(DSN)
        self.listen_conn.set_session(autocommit=True)
        self.listen_cur = self.listen_conn.cursor()
        self.listen_cur.execute(f"LISTEN {CHANNEL_READY};")
        self.listen_cur.execute(f"LISTEN {CHANNEL_DENIED};")

        # OPS connection (for queries/writes)
        self.ops_conn = psycopg2.connect(DSN)
        self.ops_cur  = self.ops_conn.cursor()

        self.running = False
        signal.signal(signal.SIGINT,  self._sig_term)
        signal.signal(signal.SIGTERM, self._sig_term)
        try:
            signal.signal(signal.SIGHUP, self._sig_hup)
        except Exception:
            pass

        logger.info("Malcolm initialized | mode=%s | quote=%s", current_mode(), self.cfg.quote)

    # ─────────────────────────── Main loop ────────────────────────────
    def run_forever(self):
        self.running = True
        last_hb = 0.0
        cycle = 0

        logger.info("Malcolm loop starting…")
        while self.running:
            now = time.time()
            if now - last_hb >= HEARTBEAT_SEC:
                self._heartbeat(cycle)
                last_hb = now

            # Non-blocking wait for notifications
            r, _, _ = select.select([self.listen_conn], [], [], LOOP_SLEEP)
            if r:
                self.listen_conn.poll()
                while self.listen_conn.notifies:
                    note = self.listen_conn.notifies.pop(0)
                    self._route_notify(note.channel, note.payload)

            # Opportunistic proposal generation (kept light; Lamar/DrCalvin do the heavy lifting)
            try:
                self._maybe_generate_proposals()
            except Exception as e:
                logger.debug("proposal-gen skipped: %s", e)

            cycle += 1

        logger.info("Malcolm loop stopped.")

    # ────────────────────── Notifications routing ─────────────────────
    def _route_notify(self, channel: str, payload: str):
        data = self._parse_payload(payload)

        if channel == CHANNEL_READY:
            self._on_ready(data)
        elif channel == CHANNEL_DENIED:
            self._on_denied(data)
        else:
            logger.debug("Ignoring channel=%s payload=%r", channel, payload)

    def _parse_payload(self, payload: str) -> Dict[str, Any]:
        try:
            return json.loads(payload)
        except Exception:
            d = {"raw": payload}
            s = payload.strip()
            if s.startswith("id:"):
                try:
                    d["proposal_id"] = int(s.split(":", 1)[1])
                except Exception:
                    pass
            return d

    # ──────────────────────── Handlers ────────────────────────────────
    def _on_ready(self, data: Dict[str, Any]):
        pid = data.get("proposal_id")
        if not pid:
            logger.error("READY missing proposal_id: %r", data)
            return

        prop = self._fetch_proposal(pid)
        if not prop:
            logger.error("proposal %s not found or not in APPROVED/READY state", pid)
            return

        mode = current_mode()
        # Gate: if mode doesn't allow real placement, just record a shadow finalize
        if not can_place_orders() or mode in ("shadow", "halted", "maintenance", "drain"):
            logger.info("[mode:%s] would BUY %s @%s x%s (shadow only)",
                        mode, prop["symbol"], prop["price_intent"], prop["size_intent"])
            self._mark_finalized(pid, ghost=True)
            self._log_route(pid, status="shadow-finalized", info={"mode": mode})
            return

        # Risk sanity (light; full vet happened upstream)
        if not self._risk_ok(prop):
            self._fail_proposal(pid, reason="risk_blocked")
            return

        # Place limit order on exchange
        try:
            order_id = self.client.create_limit_order(
                symbol=prop["symbol"],
                side="buy",
                price=float(prop["price_intent"]),
                size=float(prop["size_intent"]),
            )
        except Exception as e:
            logger.error("order placement failed proposal=%s: %s", pid, e)
            # Unwind any sim hold via Julius (live mode → no-op)
            self._safe_julius_cancel(reason="placement_failed", proposal_id=pid)
            self._fail_proposal(pid, reason="placement_failed")
            return

        # Link hold → order in SIM (live reserves are internal to exchange)
        self._safe_julius_link(order_id=order_id, proposal_id=pid)

        # Persist order intent via Andi (TQT)
        self._safe_andi_queue(
            proposal_id=pid,
            symbol=prop["symbol"],
            side="buy",
            price=float(prop["price_intent"]),
            size=float(prop["size_intent"]),
            order_id=order_id,
            mode=mode,
            origin="malcolm",
        )

        # finalize
        self._mark_finalized(pid)
        self._log_route(pid, status="finalized", info={"order_id": order_id})

    def _on_denied(self, data: Dict[str, Any]):
        pid = data.get("proposal_id")
        typ = data.get("type", "denied")  # "denied" | "expired"
        if not pid:
            logger.error("DENIED missing proposal_id: %r", data)
            return
        self._log_route(pid, status=typ, info=data)
        # no further action

    # ─────────────────────── Proposal plumbing ────────────────────────
    def _fetch_proposal(self, pid: int) -> Optional[Dict[str, Any]]:
        self.ops_cur.execute("""
            SELECT id, symbol, side, price_intent, size_intent, status
            FROM proposals
            WHERE id = %s AND side = 'buy' AND status IN ('approved','ready')
        """, (pid,))
        row = self.ops_cur.fetchone()
        if not row:
            return None
        keys = ("id", "symbol", "side", "price_intent", "size_intent", "status")
        return dict(zip(keys, row))

    def _mark_finalized(self, pid: int, ghost: bool = False):
        new_status = "shadow_finalized" if ghost else "finalized"
        self.ops_cur.execute("UPDATE proposals SET status = %s WHERE id = %s", (new_status, pid))
        self.ops_conn.commit()

    def _fail_proposal(self, pid: int, reason: str):
        self.ops_cur.execute("UPDATE proposals SET status = 'failed' WHERE id = %s", (pid,))
        self.ops_conn.commit()
        self._log_route(pid, status="failed", info={"reason": reason})

    def _log_route(self, pid: int, status: str, info: Dict[str, Any]):
        try:
            self.ops_cur.execute("""
                INSERT INTO proposal_router_log (proposal_id, timestamp, status, details)
                VALUES (%s, NOW(), %s, %s)
            """, (pid, status, json.dumps(info)))
            self.ops_conn.commit()
        except Exception as e:
            logger.warning("router log insert failed p=%s: %s", pid, e)

    # ────────────────────────── Helpers ───────────────────────────────
    def _risk_ok(self, prop: Dict[str, Any]) -> bool:
        try:
            notional = float(prop["price_intent"]) * float(prop["size_intent"])
            if notional < float(self.cfg.min_trade):
                return False
            # Provide equity externally if you want stricter checks; use 0.0 here as placeholder
            return self.grayson.can_trade_pair(prop["symbol"], 0.0)
        except Exception:
            return True

    def _maybe_generate_proposals(self):
        """
        Placeholder: normally call DrCalvin to rank & insert BUY intents.
        Respect modes; skip in maintenance/halted.
        """
        m = current_mode()
        if m in ("halted", "maintenance"):
            return
        # Intentionally left minimal; Lamar handles routing → vets → approvals.

    def _safe_andi_queue(self, **kw):
        try:
            andi.queue_order(**kw)
        except Exception as e:
            logger.warning("andi.queue_order warn: %s", e)

    def _safe_julius_link(self, order_id: str, proposal_id: int):
        """
        Prefer correlation-based linking (no hold_id in proposals).
        Falls back quietly if your Julius doesn't yet support correlation_id.
        """
        try:
            # New API (recommended): correlation by proposal
            if hasattr(self.julius, "link_hold_to_order"):
                # try modern signature first
                try:
                    self.julius.link_hold_to_order(order_id=order_id, correlation_id=f"proposal:{proposal_id}")
                    return
                except TypeError:
                    pass
            # Optional alternates your Julius may expose
            if hasattr(self.julius, "link_order_to_proposal"):
                self.julius.link_order_to_proposal(proposal_id=proposal_id, order_id=order_id)
        except Exception as e:
            logger.debug("julius link skipped: %s", e)

    def _safe_julius_cancel(self, reason: str, proposal_id: int):
        try:
            if hasattr(self.julius, "on_cancel"):
                try:
                    self.julius.on_cancel(reason=reason, correlation_id=f"proposal:{proposal_id}")
                except TypeError:
                    # legacy signature: on_cancel(order_id=None, reason, hold_id=None)
                    self.julius.on_cancel(order_id=None, reason=reason, hold_id=None)
        except Exception as e:
            logger.debug("julius on_cancel skipped: %s", e)

    # ───────────────────────── Heartbeats ─────────────────────────────
    def _heartbeat(self, cycle_count: int):
        try:
            self.ops_cur.execute("""
                INSERT INTO heartbeats (process_name, last_heartbeat, status, pid, cycle_count)
                VALUES (%s, NOW(), 'ok', %s, %s)
                ON CONFLICT (process_name)
                DO UPDATE SET last_heartbeat = EXCLUDED.last_heartbeat,
                              status         = EXCLUDED.status,
                              pid            = EXCLUDED.pid,
                              cycle_count    = EXCLUDED.cycle_count
            """, (PROCESS_NAME, os.getpid(), cycle_count))
            self.ops_conn.commit()
        except Exception as e:
            logger.warning("heartbeat failed: %s", e)

    # ─────────────────────── Signal handlers ──────────────────────────
    def _sig_term(self, *_):
        self.running = False
        try:
            self.ops_conn.commit()
        except Exception:
            pass
        try:
            if PID_PATH.exists():
                PID_PATH.unlink()
        except Exception:
            pass
        logger.info("Malcolm stopped (SIGTERM/SIGINT).")

    def _sig_hup(self, *_):
        # lightweight “reload”: toggle log level; mode is read on each use via current_mode()
        new = logging.DEBUG if logger.level != logging.DEBUG else logging.INFO
        logger.setLevel(new)
        logger.info("Malcolm received SIGHUP → log level now %s", logging.getLevelName(new))

# ─────────────────────────── Entrypoint ───────────────────────────────
if __name__ == "__main__":
    Malcolm().run_forever()

================================================================================
FILE: mm/core/petra.py
================================================================================
#>> A R I A N D E [v 6.1]
#>> last update: 2025 | Sept. 9                ❌ PRODUCTION READY
#>>
#>> Sales Manager
#>> mm/core/petra.py
#>>
#>> Responsible for selling inventory positions
#>> Identifies profitable exit opportunities  
#>> Places limit sell orders with proper spread
#>>
#>> Auth'd -> Commander
#>>
#>> [520] [741] [8]        💫 PERSISTANT RUNTIME  ➰ MONIT MANAGED     
#>>----------------------------------------------------------------

# Build|20250909.01

import os
import json
import time
import select
import signal
import pathlib
import logging
import logging.handlers
from dataclasses import dataclass
from typing import Optional, Dict, Any

import psycopg2

from mm.config import marcus
from mm.core.grayson import Grayson
from mm.conn.conn_kucoin import KucoinClient
from mm.utils.tqt import andi

# Helen: inventory manager (asset holds)
try:
    from mm.core.helen import Helen
except Exception:
    Helen = None  # graceful fallback; guarded calls below

# Inara helpers (fallbacks keep Petra runnable if inara.py is older)
try:
    from mm.utils.helpers.inara import current_mode, can_place_orders, is_live_mode
except Exception:
    def current_mode() -> str:
        return getattr(marcus, "MODE", "simulation")
    def can_place_orders() -> bool:
        return current_mode() in ("live", "simulation", "shadow")
    def is_live_mode() -> bool:
        return current_mode() == "live"

# ────────────────────────── Config / Paths ────────────────────────────
DSN = os.getenv("PG_DSN", "dbname=ariadne user=postgres host=localhost")
CHANNEL_READY  = "proposals.ready.petra"
CHANNEL_DENIED = "proposals.denied.petra"
PROCESS_NAME   = "petra"

LOG_PATH = pathlib.Path("mm/logs/petra.log")
PID_PATH = pathlib.Path("mm/utils/soc/petra.pid")

HEARTBEAT_SEC = 5
LOOP_SLEEP    = 0.25

logger = logging.getLogger("petra")
logger.setLevel(logging.INFO)

def _setup_logging():
    LOG_PATH.parent.mkdir(parents=True, exist_ok=True)
    fh = logging.handlers.RotatingFileHandler(LOG_PATH, maxBytes=5_000_000, backupCount=3)
    fh.setFormatter(logging.Formatter('[%(asctime)s] %(levelname)s %(message)s'))
    logger.addHandler(fh)
    ch = logging.StreamHandler()
    ch.setFormatter(logging.Formatter('%(message)s'))
    logger.addHandler(ch)

def _write_pid():
    PID_PATH.parent.mkdir(parents=True, exist_ok=True)
    PID_PATH.write_text(str(os.getpid()))

@dataclass
class PetraCfg:
    quote: str = marcus.QUOTE_CURRENCY
    min_trade: float = getattr(marcus, "MIN_TRADE_SIZE", 10.0)

class Petra:
    """
    SELL Originator:
      - Maintains two DB connections (LISTEN vs ops)
      - Reacts to proposals.ready.petra / proposals.denied.petra
      - On READY: place limit order (mode-gated); link/unwind asset holds via Helen (sim), queue to Andi
      - On DENIED/EXPIRED: log and stop progression
      - Generates lightweight sell proposals opportunistically (stub; DrCalvin/Lamar usually drive)
    """

    def __init__(self, client: Optional[KucoinClient] = None, cfg: PetraCfg = PetraCfg()):
        _setup_logging()
        _write_pid()

        self.cfg = cfg
        self.client = client or KucoinClient()
        self.grayson = Grayson()
        self.helen = Helen(self.client) if Helen else None

        # LISTEN connection (autocommit ON)
        self.listen_conn = psycopg2.connect(DSN)
        self.listen_conn.set_session(autocommit=True)
        self.listen_cur = self.listen_conn.cursor()
        self.listen_cur.execute(f"LISTEN {CHANNEL_READY};")
        self.listen_cur.execute(f"LISTEN {CHANNEL_DENIED};")

        # OPS connection (for queries/writes)
        self.ops_conn = psycopg2.connect(DSN)
        self.ops_cur  = self.ops_conn.cursor()

        self.running = False
        signal.signal(signal.SIGINT,  self._sig_term)
        signal.signal(signal.SIGTERM, self._sig_term)
        try:
            signal.signal(signal.SIGHUP, self._sig_hup)
        except Exception:
            pass

        logger.info("Petra initialized | mode=%s | quote=%s", current_mode(), self.cfg.quote)

    # ─────────────────────────── Main loop ────────────────────────────
    def run_forever(self):
        self.running = True
        last_hb = 0.0
        cycle = 0

        logger.info("Petra loop starting…")
        while self.running:
            now = time.time()
            if now - last_hb >= HEARTBEAT_SEC:
                self._heartbeat(cycle)
                last_hb = now

            # Non-blocking wait for notifications
            r, _, _ = select.select([self.listen_conn], [], [], LOOP_SLEEP)
            if r:
                self.listen_conn.poll()
                while self.listen_conn.notifies:
                    note = self.listen_conn.notifies.pop(0)
                    self._route_notify(note.channel, note.payload)

            # Opportunistic proposal generation (kept light)
            try:
                self._maybe_generate_proposals()
            except Exception as e:
                logger.debug("proposal-gen skipped: %s", e)

            cycle += 1

        logger.info("Petra loop stopped.")

    # ────────────────────── Notifications routing ─────────────────────
    def _route_notify(self, channel: str, payload: str):
        data = self._parse_payload(payload)

        if channel == CHANNEL_READY:
            self._on_ready(data)
        elif channel == CHANNEL_DENIED:
            self._on_denied(data)
        else:
            logger.debug("Ignoring channel=%s payload=%r", channel, payload)

    def _parse_payload(self, payload: str) -> Dict[str, Any]:
        try:
            return json.loads(payload)
        except Exception:
            d = {"raw": payload}
            s = payload.strip()
            if s.startswith("id:"):
                try:
                    d["proposal_id"] = int(s.split(":", 1)[1])
                except Exception:
                    pass
            return d

    # ──────────────────────── Handlers ────────────────────────────────
    def _on_ready(self, data: Dict[str, Any]):
        pid = data.get("proposal_id")
        if not pid:
            logger.error("READY missing proposal_id: %r", data)
            return

        prop = self._fetch_proposal(pid)
        if not prop:
            logger.error("proposal %s not found or not in APPROVED/READY state", pid)
            return

        mode = current_mode()
        # Gate: if mode doesn't allow real placement, just record a shadow finalize
        if not can_place_orders() or mode in ("shadow", "halted", "maintenance", "drain"):
            logger.info("[mode:%s] would SELL %s @%s x%s (shadow only)",
                        mode, prop["symbol"], prop["price_intent"], prop["size_intent"])
            self._mark_finalized(pid, ghost=True)
            self._log_route(pid, status="shadow-finalized", info={"mode": mode})
            return

        # Risk sanity (light; full vet happened upstream)
        if not self._risk_ok(prop):
            self._fail_proposal(pid, reason="risk_blocked")
            return

        # Place limit order on exchange
        try:
            order_id = self.client.create_limit_order(
                symbol=prop["symbol"],
                side="sell",
                price=float(prop["price_intent"]),
                size=float(prop["size_intent"]),
            )
        except Exception as e:
            logger.error("order placement failed proposal=%s: %s", pid, e)
            # Unwind any sim asset hold via Helen (live mode → no-op)
            self._safe_helen_cancel(reason="placement_failed", proposal_id=pid)
            self._fail_proposal(pid, reason="placement_failed")
            return

        # Link asset hold → order in SIM (live reserves are internal to exchange)
        self._safe_helen_link(order_id=order_id, proposal_id=pid)

        # Persist order intent via Andi (TQT)
        self._safe_andi_queue(
            proposal_id=pid,
            symbol=prop["symbol"],
            side="sell",
            price=float(prop["price_intent"]),
            size=float(prop["size_intent"]),
            order_id=order_id,
            mode=mode,
            origin="petra",
        )

        # finalize
        self._mark_finalized(pid)
        self._log_route(pid, status="finalized", info={"order_id": order_id})

    def _on_denied(self, data: Dict[str, Any]):
        pid = data.get("proposal_id")
        typ = data.get("type", "denied")  # "denied" | "expired"
        if not pid:
            logger.error("DENIED missing proposal_id: %r", data)
            return
        self._log_route(pid, status=typ, info=data)
        # no further action

    # ─────────────────────── Proposal plumbing ────────────────────────
    def _fetch_proposal(self, pid: int) -> Optional[Dict[str, Any]]:
        self.ops_cur.execute("""
            SELECT id, symbol, side, price_intent, size_intent, status
            FROM proposals
            WHERE id = %s AND side = 'sell' AND status IN ('approved','ready')
        """, (pid,))
        row = self.ops_cur.fetchone()
        if not row:
            return None
        keys = ("id", "symbol", "side", "price_intent", "size_intent", "status")
        return dict(zip(keys, row))

    def _mark_finalized(self, pid: int, ghost: bool = False):
        new_status = "shadow_finalized" if ghost else "finalized"
        self.ops_cur.execute("UPDATE proposals SET status = %s WHERE id = %s", (new_status, pid))
        self.ops_conn.commit()

    def _fail_proposal(self, pid: int, reason: str):
        self.ops_cur.execute("UPDATE proposals SET status = 'failed' WHERE id = %s", (pid,))
        self.ops_conn.commit()
        self._log_route(pid, status="failed", info={"reason": reason})

    def _log_route(self, pid: int, status: str, info: Dict[str, Any]):
        try:
            self.ops_cur.execute("""
                INSERT INTO proposal_router_log (proposal_id, timestamp, status, details)
                VALUES (%s, NOW(), %s, %s)
            """, (pid, status, json.dumps(info)))
            self.ops_conn.commit()
        except Exception as e:
            logger.warning("router log insert failed p=%s: %s", pid, e)

    # ────────────────────────── Helpers ───────────────────────────────
    def _risk_ok(self, prop: Dict[str, Any]) -> bool:
        try:
            notional = float(prop["price_intent"]) * float(prop["size_intent"])
            if notional < float(self.cfg.min_trade):
                return False
            # Provide equity externally if you want stricter checks; use 0.0 here as placeholder
            return self.grayson.can_trade_pair(prop["symbol"], 0.0)
        except Exception:
            return True

    def _maybe_generate_proposals(self):
        """
        Placeholder: normally call DrCalvin to rank & insert SELL intents based on inventory signals.
        Respect modes; skip in maintenance/halted.
        """
        m = current_mode()
        if m in ("halted", "maintenance"):
            return
        # Intentionally left minimal; Lamar handles routing → vets → approvals.

    def _safe_andi_queue(self, **kw):
        try:
            andi.queue_order(**kw)
        except Exception as e:
            logger.warning("andi.queue_order warn: %s", e)

    def _safe_helen_link(self, order_id: str, proposal_id: int):
        """
        Prefer correlation-based linking (no hold_id in proposals).
        Falls back quietly if your Helen expects (hold_id, order_id).
        """
        if not self.helen:
            return
        try:
            # Preferred: correlation id
            if hasattr(self.helen, "link_asset_hold_to_order"):
                try:
                    # new signature with correlation_id
                    self.helen.link_asset_hold_to_order(order_id=order_id, correlation_id=f"proposal:{proposal_id}")
                    return
                except TypeError:
                    pass
                # legacy: requires hold_id (Helen maps proposal→hold on her side or ignores)
                try:
                    self.helen.link_asset_hold_to_order(None, order_id)  # best-effort
                except Exception:
                    pass
        except Exception as e:
            logger.debug("helen link skipped: %s", e)

    def _safe_helen_cancel(self, reason: str, proposal_id: int):
        if not self.helen:
            return
        try:
            if hasattr(self.helen, "on_cancel"):
                try:
                    self.helen.on_cancel(reason=reason, correlation_id=f"proposal:{proposal_id}")
                except TypeError:
                    self.helen.on_cancel(order_id=None, reason=reason)
        except Exception as e:
            logger.debug("helen on_cancel skipped: %s", e)

    # ───────────────────────── Heartbeats ─────────────────────────────
    def _heartbeat(self, cycle_count: int):
        try:
            self.ops_cur.execute("""
                INSERT INTO heartbeats (process_name, last_heartbeat, status, pid, cycle_count)
                VALUES (%s, NOW(), 'ok', %s, %s)
                ON CONFLICT (process_name)
                DO UPDATE SET last_heartbeat = EXCLUDED.last_heartbeat,
                              status         = EXCLUDED.status,
                              pid            = EXCLUDED.pid,
                              cycle_count    = EXCLUDED.cycle_count
            """, (PROCESS_NAME, os.getpid(), cycle_count))
            self.ops_conn.commit()
        except Exception as e:
            logger.warning("heartbeat failed: %s", e)

    # ─────────────────────── Signal handlers ──────────────────────────
    def _sig_term(self, *_):
        self.running = False
        try:
            self.ops_conn.commit()
        except Exception:
            pass
        try:
            if PID_PATH.exists():
                PID_PATH.unlink()
        except Exception:
            pass
        logger.info("Petra stopped (SIGTERM/SIGINT).")

    def _sig_hup(self, *_):
        # lightweight “reload”: toggle log level; mode is read on each use via current_mode()
        new = logging.DEBUG if logger.level != logging.DEBUG else logging.INFO
        logger.setLevel(new)
        logger.info("Petra received SIGHUP → log level now %s", logging.getLevelName(new))

# ─────────────────────────── Entrypoint ───────────────────────────────
if __name__ == "__main__":
    Petra().run_forever()

================================================================================
FILE: mm/core/naomi.py
================================================================================
#>> A R I A N D E v6
#>> last update: 2025 | Sept. 5
#>>
#>> Panic Manager
#>> mm/core/naomi.py
#>>
#>> Emergency response system for market crises
#>> Monitors for crashes, illiquidity, and extreme volatility.
#>>
#>> Auth'd -> Commander
#>>
#>> [520] [741] [8]    
#>>----------------------------------------------------------------

# Build|20250905.01

import logging
import time
from typing import Dict, List, Optional, Tuple
from datetime import datetime, timedelta

# Import config parameters
from mm.config.marcus import (
    PANIC_PRICE_MOVE_PCT, PANIC_VOLUME_SPIKE,
    PANIC_LOSS_THRESHOLD, PANIC_POSITION_LOSS_PCT,
    CONSECUTIVE_LOSS_LIMIT, QUOTE_CURRENCY,
    ALERT_EMAIL_ENABLED, ALERT_EMAIL_ADDRESS, 
    ALERT_EMAIL_RECIPIENT
)

# Email imports (conditional)
if ALERT_EMAIL_ENABLED:
    import smtplib
    from email.mime.text import MIMEText
    from mm.utils.helpers.timezone import get_email_date

# ── Logger Setup ──────────────────────────────────────────────────────
logger = logging.getLogger('ariadne.panic')

class Naomi:
    """
    Monitors for panic conditions and triggers emergency procedures
    """
    
    def __init__(self):
        """Initialize panic monitoring structures"""
        self.logger = logger
        self.price_history: Dict[str, List[Tuple[float, float]]] = {}  # symbol -> [(timestamp, price)]
        self.volume_history: Dict[str, List[Tuple[float, float]]] = {}  # symbol -> [(timestamp, volume)]
        self.consecutive_losses: int = 0
        self.last_check_time: float = 0
        self.panic_events: List[Dict] = []
        self.cooldown_until: Optional[float] = None
        
    def check_panic_conditions(self, positions: Dict[str, float], 
                             total_equity: float) -> Dict:
        """
        Check all panic conditions
        
        Args:
            positions: Current positions by symbol
            total_equity: Total account equity
            
        Returns:
            Dict with panic status and recommended actions
        """
        # Check cooldown
        if self.cooldown_until and time.time() < self.cooldown_until:
            return {
                'panic_mode': False,
                'in_cooldown': True,
                'cooldown_remaining': self.cooldown_until - time.time()
            }
        
        panic_triggers = []
        
        # Check for flash crash/spike in any position
        for symbol in positions:
            price_spike = self._check_price_spike(symbol)
            if price_spike:
                panic_triggers.append({
                    'type': 'price_spike',
                    'symbol': symbol,
                    'severity': 'critical',
                    'details': price_spike
                })
        
        # Check for abnormal volume
        volume_anomalies = self._check_volume_anomalies(positions.keys())
        if volume_anomalies:
            panic_triggers.extend(volume_anomalies)
        
        # Check position-specific losses
        position_panics = self._check_position_losses(positions, total_equity)
        if position_panics:
            panic_triggers.extend(position_panics)
        
        # Check consecutive losses
        if self.consecutive_losses >= CONSECUTIVE_LOSS_LIMIT:
            panic_triggers.append({
                'type': 'consecutive_losses',
                'severity': 'high',
                'count': self.consecutive_losses,
                'details': f'{self.consecutive_losses} consecutive losing trades'
            })
        
        # Determine action based on triggers
        if not panic_triggers:
            return {
                'panic_mode': False,
                'triggers': [],
                'reason': None
            }
        
        # Classify severity
        critical_count = sum(1 for t in panic_triggers if t['severity'] == 'critical')
        high_count = sum(1 for t in panic_triggers if t['severity'] == 'high')
        
        # Determine action
        if critical_count > 0:
            action = 'close_all'
            close_positions = True
        elif high_count >= 2:
            action = 'cancel_orders'
            close_positions = False
        else:
            action = 'monitor'
            close_positions = False
        
        # Log panic event
        panic_event = {
            'timestamp': time.time(),
            'triggers': panic_triggers,
            'action': action,
            'equity': total_equity
        }
        self.panic_events.append(panic_event)
        
        # Send alert
        if action in ['close_all', 'cancel_orders']:
            self._send_panic_alert(panic_triggers, action)
        
        # Set cooldown if taking action
        if action != 'monitor':
            self.cooldown_until = time.time() + 300  # 5 minute cooldown
        
        reason = self._format_panic_reason(panic_triggers)
        
        return {
            'panic_mode': action != 'monitor',
            'action': action,
            'close_positions': close_positions,
            'triggers': panic_triggers,
            'reason': reason
        }
    
    def _check_price_spike(self, symbol: str) -> Optional[Dict]:
        """
        Check for sudden price movements
        
        Args:
            symbol: Trading pair symbol
            
        Returns:
            Spike details or None
        """
        if symbol not in self.price_history:
            return None
            
        history = self.price_history[symbol]
        if len(history) < 2:
            return None
        
        # Get current and 1-minute ago prices
        current_price = history[-1][1]
        
        # Find price from ~60 seconds ago
        current_time = time.time()
        for timestamp, price in reversed(history[:-1]):
            if current_time - timestamp >= 60:
                minute_ago_price = price
                break
        else:
            return None
        
        # Calculate percentage change
        if minute_ago_price > 0:
            change_pct = abs((current_price - minute_ago_price) / minute_ago_price)
            
            if change_pct >= PANIC_PRICE_MOVE_PCT:
                return {
                    'move_pct': change_pct,
                    'from_price': minute_ago_price,
                    'to_price': current_price,
                    'direction': 'spike' if current_price > minute_ago_price else 'crash'
                }
        
        return None
    
    def _check_volume_anomalies(self, symbols: List[str]) -> List[Dict]:
        """
        Check for abnormal volume spikes
        
        Args:
            symbols: List of symbols to check
            
        Returns:
            List of volume anomalies
        """
        anomalies = []
        
        for symbol in symbols:
            if symbol not in self.volume_history:
                continue
            
            history = self.volume_history[symbol]
            if len(history) < 10:  # Need history for average
                continue
            
            # Calculate average volume
            recent_volumes = [v for _, v in history[-10:]]
            avg_volume = sum(recent_volumes) / len(recent_volumes)
            current_volume = history[-1][1]
            
            if avg_volume > 0:
                volume_ratio = current_volume / avg_volume
                
                if volume_ratio >= PANIC_VOLUME_SPIKE:
                    anomalies.append({
                        'type': 'volume_spike',
                        'symbol': symbol,
                        'severity': 'high',
                        'details': {
                            'ratio': volume_ratio,
                            'current': current_volume,
                            'average': avg_volume
                        }
                    })
        
        return anomalies
    
    def _check_position_losses(self, positions: Dict[str, float], 
                              total_equity: float) -> List[Dict]:
        """
        Check for significant position losses
        
        Args:
            positions: Current positions
            total_equity: Total equity
            
        Returns:
            List of position-specific panic triggers
        """
        triggers = []
        
        # This would need access to entry prices to calculate actual losses
        # For now, we'll skip this check
        # TODO: Integrate with trade history for actual P&L
        
        return triggers
    
    def update_price_history(self, symbol: str, price: float):
        """
        Update price tracking
        
        Args:
            symbol: Trading pair symbol
            price: Current price
        """
        if symbol not in self.price_history:
            self.price_history[symbol] = []
        
        # Add new price point
        self.price_history[symbol].append((time.time(), price))
        
        # Keep only last 5 minutes of history
        cutoff = time.time() - 300
        self.price_history[symbol] = [
            (t, p) for t, p in self.price_history[symbol] if t > cutoff
        ]
    
    def update_volume_history(self, symbol: str, volume: float):
        """
        Update volume tracking
        
        Args:
            symbol: Trading pair symbol
            volume: Current volume
        """
        if symbol not in self.volume_history:
            self.volume_history[symbol] = []
        
        # Add new volume point
        self.volume_history[symbol].append((time.time(), volume))
        
        # Keep only last 30 minutes of history
        cutoff = time.time() - 1800
        self.volume_history[symbol] = [
            (t, v) for t, v in self.volume_history[symbol] if t > cutoff
        ]
    
    def register_trade_result(self, profit: bool):
        """
        Register trade outcome for consecutive loss tracking
        
        Args:
            profit: True if profitable, False if loss
        """
        if profit:
            self.consecutive_losses = 0
        else:
            self.consecutive_losses += 1
            
            if self.consecutive_losses >= CONSECUTIVE_LOSS_LIMIT:
                self.logger.warning(f"Consecutive losses: {self.consecutive_losses}")
    
    def reset_cooldown(self):
        """Manually reset panic cooldown"""
        self.cooldown_until = None
        self.logger.info("Panic cooldown reset")
    
    def get_panic_report(self) -> Dict:
        """
        Get current panic monitoring status
        
        Returns:
            Dict with panic metrics
        """
        return {
            'consecutive_losses': self.consecutive_losses,
            'monitored_symbols': len(self.price_history),
            'in_cooldown': bool(self.cooldown_until and time.time() < self.cooldown_until),
            'cooldown_remaining': max(0, self.cooldown_until - time.time()) if self.cooldown_until else 0,
            'recent_events': self.panic_events[-5:],  # Last 5 panic events
            'price_history_size': {s: len(h) for s, h in self.price_history.items()},
            'volume_history_size': {s: len(h) for s, h in self.volume_history.items()}
        }
    
    def _format_panic_reason(self, triggers: List[Dict]) -> str:
        """
        Format human-readable panic reason
        
        Args:
            triggers: List of panic triggers
            
        Returns:
            Formatted reason string
        """
        if not triggers:
            return "No panic conditions"
        
        reasons = []
        for trigger in triggers[:3]:  # Top 3 reasons
            if trigger['type'] == 'price_spike':
                direction = trigger['details']['direction']
                pct = trigger['details']['move_pct'] * 100
                reasons.append(f"{trigger['symbol']} {direction} {pct:.1f}%")
            elif trigger['type'] == 'volume_spike':
                ratio = trigger['details']['ratio']
                reasons.append(f"{trigger['symbol']} volume {ratio:.1f}x normal")
            elif trigger['type'] == 'consecutive_losses':
                reasons.append(f"{trigger['count']} consecutive losses")
        
        return "; ".join(reasons)
    
    def _send_panic_alert(self, triggers: List[Dict], action: str):
        """
        Send panic alert email
        
        Args:
            triggers: List of triggers
            action: Recommended action
        """
        if not ALERT_EMAIL_ENABLED:
            return
        
        # Format message
        message = f"PANIC CONDITIONS DETECTED\n\n"
        message += f"Action: {action.upper()}\n\n"
        message += "Triggers:\n"
        
        for trigger in triggers:
            message += f"- {trigger['type']}: "
            if 'symbol' in trigger:
                message += f"{trigger['symbol']} "
            if 'details' in trigger:
                message += f"{trigger['details']}\n"
            else:
                message += "\n"
        
        try:
            msg = MIMEText(message)
            msg['Subject'] = f"🚨 PANIC ALERT - {get_email_date()}"
            msg['From'] = ALERT_EMAIL_ADDRESS
            msg['To'] = ALERT_EMAIL_RECIPIENT
            msg['Date'] = get_email_date()
            msg['X-Priority'] = '1'  # Highest priority
            
            server = smtplib.SMTP_SSL(ALERT_EMAIL_SMTP_SERVER, ALERT_EMAIL_SMTP_PORT)
            server.login(ALERT_EMAIL_ADDRESS, ALERT_EMAIL_PASSWORD)
            server.sendmail(ALERT_EMAIL_ADDRESS, [ALERT_EMAIL_RECIPIENT], msg.as_string())
            server.quit()
            
            self.logger.info("Panic alert email sent")
        except Exception as e:
            self.logger.error(f"Failed to send panic alert: {e}")

================================================================================
FILE: mm/core/julius.py
================================================================================
#>> A R I A N D E [v 6.1]
#>> last update: 2025 | Sept. 9                ❌ PRODUCTION READY
#>>
#>> The Banker
#>> mm/core/julius.py
#>>
#>> The single point of truth for cash/wallet state inside 
#>> the system.
#>>
#>> Auth'd -> Commander
#>>
#>> [520] [741] [8]        💫 PERSISTANT RUNTIME  ➰ MONIT MANAGED
#>>────────────────────────────────────────────────────────────────

# Build|20250909.01

import os
import json
import logging
from dataclasses import dataclass
from typing import Dict, Optional, Tuple

import psycopg2

from mm.config import marcus
from mm.conn.conn_kucoin import KucoinClient

# Inara (mode gating). Safe fallbacks if helpers are older.
try:
    from mm.utils.helpers.inara import current_mode, is_live_mode
except Exception:
    def current_mode() -> str:
        return getattr(marcus, "MODE", "simulation")
    def is_live_mode() -> bool:
        return current_mode() == "live"

DSN = os.getenv("PG_DSN", "dbname=ariadne user=postgres host=localhost")

logger = logging.getLogger("julius")
logger.setLevel(logging.INFO)


@dataclass
class JuliusCfg:
    quote: str = getattr(marcus, "QUOTE_CURRENCY", "USDT")
    min_trade: float = getattr(marcus, "MIN_TRADE_SIZE", 10.0)


class Julius:
    """
    Responsibilities
      • Phase 1 (vet): set proposals.bank_vet ← 'approved' | 'denied' based on QUOTE wallet availability.
      • Phase 2 (finalize for BUY):
          - SIM: reserve by incrementing sim_balances.hold for QUOTE.
          - LIVE: no DB hold (exchange will reserve at order); optional recheck.
          - Set proposals.status = 'approved' (idempotent) and log.
      • Interfaces for Malcolm:
          - link_hold_to_order(order_id, correlation_id="proposal:{id}") → log linkage (SIM reserve already done).
          - on_cancel(reason, correlation_id="proposal:{id}") → release SIM reservation + mark proposal failed (idempotent).
      • get_balances(): unified balances for UI/loop (LIVE via exchange; SIM via sim_balances).
    """

    def __init__(self, client: Optional[KucoinClient] = None, cfg: JuliusCfg = JuliusCfg()):
        self.cfg = cfg
        self.client = client or KucoinClient()
        self.conn = psycopg2.connect(DSN)
        self.cur = self.conn.cursor()
        logger.info("Julius ready | mode=%s | quote=%s", current_mode(), self.cfg.quote)

    # ───────────────────────── Public API ─────────────────────────

    def get_balances(self) -> Dict[str, Dict[str, float]]:
        """
        Returns { 'USDT': {'available': x, 'hold': y, 'total': z}, ... }.
        LIVE → KuCoin accounts; SIM → sim_balances (best-effort across common schemas).
        """
        if is_live_mode():
            return self._live_balances()
        return self._sim_balances()

    def vet_bank(self, proposal_id: int) -> str:
        """Phase 1: set bank_vet = 'approved' or 'denied' for BUY proposal."""
        prop = self._fetch_proposal(proposal_id)
        if not prop or prop["side"] != "buy":
            return "denied"

        notional = float(prop["price_intent"]) * float(prop["size_intent"])
        if notional < float(self.cfg.min_trade):
            self._set_vet(proposal_id, "bank_vet", "denied")
            self._route_log(proposal_id, "bank.denied", {"reason": "min_trade"})
            return "denied"

        ok = self._has_funds(notional)
        status = "approved" if ok else "denied"
        self._set_vet(proposal_id, "bank_vet", status)
        self._route_log(proposal_id, f"bank.{status}", {"notional": notional, "quote": self.cfg.quote})
        return status

    def finalize_for_buy(self, proposal_id: int) -> bool:
        """
        Phase 2 for Malcolm-originated proposals: after Lamar sees all vets approved,
        Lamar calls Julius to reserve funds before signaling Malcolm.
        SIM: increment sim_balances.hold atomically; LIVE: re-validate only.
        """
        prop = self._fetch_proposal(proposal_id, for_finalize=True)
        if not prop or prop["side"] != "buy":
            self._route_log(proposal_id, "bank_finalize.failed", {"reason": "not_found_or_wrong_side"})
            return False

        notional = float(prop["price_intent"]) * float(prop["size_intent"])

        if is_live_mode():
            if not self._has_funds(notional):
                self._route_log(proposal_id, "bank_finalize.denied", {"reason": "insufficient_live_funds"})
                return False
            # Approved in LIVE (exchange will reserve later)
            self._safe_set_status(proposal_id, "approved")
            self._route_log(proposal_id, "bank_finalize.live_ok", {"notional": notional, "quote": self.cfg.quote})
            return True

        # SIM: place a reservation by bumping sim_balances.hold atomically
        if not self._reserve_sim_funds(notional):
            self._route_log(proposal_id, "bank_finalize.denied", {"reason": "insufficient_sim_funds"})
            return False

        self._safe_set_status(proposal_id, "approved")
        self._route_log(proposal_id, "bank_finalize.approved", {"notional": notional, "quote": self.cfg.quote})
        return True

    # Called by Malcolm after successful order placement
    def link_hold_to_order(self, order_id: Optional[str] = None,
                           correlation_id: Optional[str] = None,
                           hold_id: Optional[str] = None) -> None:
        """
        SIM: reservation already made; just log linkage.
        LIVE: exchange manages reservation; just log.
        """
        pid = self._pid_from_corr(correlation_id)
        info = {"order_id": order_id, "hold_id": hold_id, "correlation_id": correlation_id}
        if pid:
            self._route_log(pid, "bank_linked", info)
        else:
            logger.info("Julius link (no pid): %s", info)

    # Called by Malcolm on placement failure to unwind a SIM reservation
    def on_cancel(self, order_id: Optional[str] = None, reason: str = "placement_failed",
                  correlation_id: Optional[str] = None, hold_id: Optional[str] = None) -> None:
        pid = self._pid_from_corr(correlation_id)
        prop = self._fetch_proposal(pid) if pid else None
        if not prop or prop["side"] != "buy":
            self._route_log(pid or -1, "bank_cancel.ignored", {"reason": "no_buy_proposal", "order_id": order_id})
            return

        notional = float(prop["price_intent"]) * float(prop["size_intent"])
        if not is_live_mode():
            self._release_sim_funds(notional)

        # Mark proposal failed (idempotent)
        self._safe_set_status(pid, "failed")
        self._route_log(pid, "bank_cancel", {
            "order_id": order_id, "reason": reason, "notional": notional, "quote": self.cfg.quote
        })

    # ───────────────────────── Internals ─────────────────────────

    def _fetch_proposal(self, pid: Optional[int], for_finalize: bool = False) -> Optional[Dict]:
        if not pid:
            return None
        if for_finalize:
            # ensure all vets are approved (risk/bank/invt)
            self.cur.execute("""
                SELECT id, symbol, side, price_intent, size_intent, risk_vet, bank_vet, invt_vet
                FROM proposals WHERE id=%s
            """, (pid,))
            row = self.cur.fetchone()
            if not row:
                return None
            d = dict(zip(
                ("id","symbol","side","price_intent","size_intent","risk_vet","bank_vet","invt_vet"), row
            ))
            if (d.get("risk_vet") != "approved") or (d.get("bank_vet") != "approved") or (d.get("invt_vet") != "approved"):
                return None
            return d
        else:
            self.cur.execute("""
                SELECT id, symbol, side, price_intent, size_intent
                FROM proposals WHERE id=%s
            """, (pid,))
            row = self.cur.fetchone()
            return dict(zip(("id","symbol","side","price_intent","size_intent"), row)) if row else None

    def _set_vet(self, pid: int, col: str, status: str) -> None:
        try:
            self.cur.execute(f"UPDATE proposals SET {col} = %s WHERE id = %s", (status, pid))
            self.conn.commit()
        except Exception as e:
            self.conn.rollback()
            logger.warning("vet update failed (%s) p=%s: %s", col, pid, e)

    def _safe_set_status(self, pid: int, status: str) -> None:
        try:
            self.cur.execute("UPDATE proposals SET status=%s WHERE id=%s", (status, pid))
            self.conn.commit()
        except Exception:
            self.conn.rollback()

    def _route_log(self, proposal_id: int, status: str, info: Dict) -> None:
        """Append to proposal_router_log for observability."""
        try:
            self.cur.execute("""
                INSERT INTO proposal_router_log (proposal_id, timestamp, status, details)
                VALUES (%s, NOW(), %s, %s)
            """, (proposal_id, status, json.dumps(info)))
            self.conn.commit()
        except Exception as e:
            self.conn.rollback()
            logger.warning("router log insert failed p=%s: %s", proposal_id, e)

    # ─────────────── Balances / availability helpers ───────────────

    def _has_funds(self, notional: float) -> bool:
        bals = self.get_balances() or {}
        q = bals.get(self.cfg.quote, {})
        avail = float(q.get("available", 0.0))
        return avail >= float(notional)

    def _live_balances(self) -> Dict[str, Dict[str, float]]:
        # { 'USDT': {'available': x, 'hold': y, 'total': x+y}, ... }
        try:
            d = self.client.get_account_balances_detailed()  # KuCoin private accounts
        except Exception:
            d = {}
        out: Dict[str, Dict[str, float]] = {}
        for cur, vals in (d or {}).items():
            avail = float(vals.get("available", 0.0) or 0.0)
            hold  = float(vals.get("hold", 0.0) or 0.0)
            out[cur] = {"available": avail, "hold": hold, "total": avail + hold}
        return out

    def _sim_balances(self) -> Dict[str, Dict[str, float]]:
        """
        Best-effort across common sim_balances schemas:
          (asset, available, hold)   OR (asset, total, hold)   OR (asset, balance, hold)
        """
        # Try #1: available+hold
        try:
            self.cur.execute("SELECT asset, COALESCE(available,0)::numeric, COALESCE(hold,0)::numeric FROM sim_balances")
            rows = self.cur.fetchall()
            out = {}
            for asset, avail, hold in rows:
                a = float(avail or 0.0); h = float(hold or 0.0)
                out[str(asset).upper()] = {"available": a, "hold": h, "total": a + h}
            return out
        except Exception:
            self.conn.rollback()

        # Try #2: total+hold
        try:
            self.cur.execute("SELECT asset, COALESCE(total,0)::numeric, COALESCE(hold,0)::numeric FROM sim_balances")
            rows = self.cur.fetchall()
            out = {}
            for asset, total, hold in rows:
                t = float(total or 0.0); h = float(hold or 0.0)
                out[str(asset).upper()] = {"available": max(0.0, t - h), "hold": h, "total": t}
            return out
        except Exception:
            self.conn.rollback()

        # Try #3: balance+hold
        try:
            self.cur.execute("SELECT asset, COALESCE(balance,0)::numeric, COALESCE(hold,0)::numeric FROM sim_balances")
            rows = self.cur.fetchall()
            out = {}
            for asset, bal, hold in rows:
                t = float(bal or 0.0); h = float(hold or 0.0)
                out[str(asset).upper()] = {"available": max(0.0, t - h), "hold": h, "total": t}
            return out
        except Exception:
            self.conn.rollback()
            return {}

    def _reserve_sim_funds(self, notional: float) -> bool:
        """
        Atomically bump sim_balances.hold for QUOTE if sufficient available remains.
        Tries common schemas in order.
        """
        q = self.cfg.quote

        # available+hold
        try:
            self.cur.execute("""
                UPDATE sim_balances
                   SET hold = hold + %s
                 WHERE asset = %s
                   AND (COALESCE(available,0) - COALESCE(hold,0)) >= %s
                RETURNING hold
            """, (notional, q, notional))
            if self.cur.fetchone():
                self.conn.commit()
                return True
            self.conn.rollback()
        except Exception:
            self.conn.rollback()

        # total+hold
        try:
            self.cur.execute("""
                UPDATE sim_balances
                   SET hold = hold + %s
                 WHERE asset = %s
                   AND (COALESCE(total,0) - COALESCE(hold,0)) >= %s
                RETURNING hold
            """, (notional, q, notional))
            if self.cur.fetchone():
                self.conn.commit()
                return True
            self.conn.rollback()
        except Exception:
            self.conn.rollback()

        # balance+hold
        try:
            self.cur.execute("""
                UPDATE sim_balances
                   SET hold = hold + %s
                 WHERE asset = %s
                   AND (COALESCE(balance,0) - COALESCE(hold,0)) >= %s
                RETURNING hold
            """, (notional, q, notional))
            if self.cur.fetchone():
                self.conn.commit()
                return True
            self.conn.rollback()
        except Exception:
            self.conn.rollback()

        return False

    def _release_sim_funds(self, notional: float) -> None:
        """Release a previous reservation in SIM (best-effort; never go below zero)."""
        q = self.cfg.quote
        try:
            self.cur.execute("""
                UPDATE sim_balances
                   SET hold = GREATEST(0, COALESCE(hold,0) - %s)
                 WHERE asset = %s
            """, (notional, q))
            self.conn.commit()
        except Exception:
            self.conn.rollback()

    # ───────────────────────── Utilities ─────────────────────────

    @staticmethod
    def _pid_from_corr(correlation_id: Optional[str]) -> Optional[int]:
        """Parse 'proposal:{id}' → id."""
        if not correlation_id:
            return None
        s = str(correlation_id).strip()
        if s.startswith("proposal:"):
            try:
                return int(s.split(":", 1)[1])
            except Exception:
                return None
        return None

================================================================================
FILE: mm/core/drcalvin.py
================================================================================
#>> A R I A N D E v6
#>> last update: 2025 | Sept. 5
#>>
#>> Scoring Algorithm
#>> mm/core/drcalvin.py
#>>
#>> Analytical layer for market analysis and decision logic. 
#>>
#>> Auth'd -> Commander
#>>
#>> [520] [741] [8]      
#>>────────────────────────────────────────────────────────────────

# Build|20250905.01

import numpy as np
from typing import Dict, List, Tuple, Optional, Any
import time
from tqdm import tqdm
from datetime import datetime 

import logging
logger = logging.getLogger("Ariadne")

from mm.config.marcus import (
    QUOTE_CURRENCY,
    MIN_24H_VOLUME,
    MAX_24H_VOLUME,
    MIN_COIN_AGE,
    LIQUIDITY,
    SPREAD_TIGHTNESS,
    ORDER_BOOK_DEPTH,
    SLIPPAGE_RESISTANCE,
    MARKET,
    VOLATILITY_PROFILE,
    VOLUME_CONSISTENCY,
    PRICE_STABILITY,
    TRADING,
    FEE_EFFICIENCY,
    EXECUTION_SPEED,
    MARKET_IMPACT,
    OPPORTUNITY_MOD,
    MIN_LIQUIDITY_SCORE
)

class ScoringEngine:
    def __init__(self, config):
        self.cfg = config
        
# ── Prefilter ──────────────────────────────────────────────────────────

    def pre_filter_pairs(self, client, all_pairs: List[str]) -> List[str]:
        try:
            all_tickers = client.get_all_tickers()
            if not all_tickers:
                return all_pairs
            
            ticker_dict = {item['symbol']: item for item in all_tickers}
            filtered_pairs = []

            for pair in all_pairs:
                if not pair.endswith(f"-{QUOTE_CURRENCY}"):
                    continue

                kucoin_symbol = client._pair(pair)
                ticker = ticker_dict.get(kucoin_symbol)

                if not ticker:
                    continue

                vol_value = float(ticker.get('volValue', 0))
                if vol_value < MIN_24H_VOLUME or vol_value > MAX_24H_VOLUME:
                    continue

                filtered_pairs.append(pair)

            mature_pairs = []
            maturity_window = int(time.time()) - (MIN_COIN_AGE * 86400)

            for pair in filtered_pairs:
                kucoin_symbol = client._pair(pair)
                candles = client.historical_ohlcv(kucoin_symbol, "1day", 8)

                if candles:
                    for candle in candles:
                        candle_timestamp = int(candle[0])
                        if maturity_window - 86400 <= candle_timestamp <= maturity_window:
                            mature_pairs.append(pair)
                            break

            return mature_pairs

        except Exception as e:
            logger.error(f"Error in prefiltering: {e}")
            return all_pairs
        
# ── Scoring ──────────────────────────────────────────────────────────

    def score_pair(self, symbol: str, client, historical_data=None) -> Dict[str, Any]:
        scores = {}
        category_breakdown = {}

        try:
            # ── Sub scores (all return 0..100) ───────────────────────────
            # LIQUIDITY (max 40 pts globally)
            spread_pct   = self._calculate_spread_score(symbol, client)            # 0..100
            depth_pct    = self._calculate_depth_score(symbol, client)             # 0..100
            slippage_pct = self._calculate_slippage_score(symbol, client)          # 0..100

            # MARKET (max 30 pts globally)
            volatility_pct = self._calculate_volatility_score(symbol, client, historical_data)  # 0..100
            volume_pct     = self._calculate_volume_consistency(symbol, client)                 # 0..100
            price_pct      = self._calculate_price_stability(symbol, client)                   # 0..100

            # TRADING (max 30 pts globally)
            fee_pct      = self._calculate_fee_efficiency(symbol, client)        # 0..100
            exec_pct     = self._calculate_execution_speed(symbol, client)       # 0..100
            impact_pct   = self._calculate_market_impact(symbol, client)         # 0..100

            # ── Convert % → global points via weights (no double-weighting) ─
            # Contribution (pts) = sub_weight * sub_pct
            spread_pts   = SPREAD_TIGHTNESS    * spread_pct
            depth_pts    = ORDER_BOOK_DEPTH    * depth_pct
            slippage_pts = SLIPPAGE_RESISTANCE * slippage_pct

            volatility_pts = VOLATILITY_PROFILE * volatility_pct
            volume_pts     = VOLUME_CONSISTENCY * volume_pct
            price_pts      = PRICE_STABILITY    * price_pct

            fee_pts    = FEE_EFFICIENCY  * fee_pct
            exec_pts   = EXECUTION_SPEED * exec_pct
            impact_pts = MARKET_IMPACT   * impact_pct

            # Category totals in points (Liquidity max 40, etc.)
            liquidity_points = spread_pts + depth_pts + slippage_pts
            market_points    = volatility_pts + volume_pts + price_pts
            trading_points   = fee_pts + exec_pts + impact_pts

            # Base score (0..100)
            base_score = liquidity_points + market_points + trading_points

            # ── Opportunity bonus (0..5 points) ──────────────────────────
            # imbalance_score is 0..100; OPPORTUNITY_MOD is 0.05 ⇒ +0..5 pts
            imbalance_score = self._calculate_order_book_imbalance(symbol, client)  # 0..100
            opportunity_boost = max(0.0, min(imbalance_score * OPPORTUNITY_MOD, 5.0))

            # Final can be 0..105 by design
            total_score = max(0.0, min(base_score + opportunity_boost, 105.0))

            # For convenience, keep simple “category scores” as points
            scores['liquidity_quality'] = liquidity_points
            scores['market_stability']  = market_points
            scores['trading_quality']   = trading_points

            # Breakdown: raw sub % and contribution pts
            category_breakdown['liquidity'] = {
                'total_points': liquidity_points,
                'subs': {
                    'spread':   {'pct': spread_pct,   'pts': spread_pts},
                    'depth':    {'pct': depth_pct,    'pts': depth_pts},
                    'slippage': {'pct': slippage_pct, 'pts': slippage_pts},
                }
            }
            category_breakdown['market'] = {
                'total_points': market_points,
                'subs': {
                    'volatility': {'pct': volatility_pct, 'pts': volatility_pts},
                    'volume':     {'pct': volume_pct,     'pts': volume_pts},
                    'price':      {'pct': price_pct,      'pts': price_pts},
                }
            }
            category_breakdown['trading'] = {
                'total_points': trading_points,
                'subs': {
                    'fee':     {'pct': fee_pct,    'pts': fee_pts},
                    'execution': {'pct': exec_pct, 'pts': exec_pts},
                    'impact': {'pct': impact_pct,  'pts': impact_pts},
                }
            }

            """
            # ── DEBUG ─────────────────────────────────────────────────────
            logger.debug(f"\n{symbol}")
            logger.debug(
                "LIQUIDITY | "
                f"{liquidity_points:5.2f} "
                f"[ Spread: {spread_pct:5.1f}% → {spread_pts:5.2f} ] "
                f"[ Depth: {depth_pct:5.1f}% → {depth_pts:5.2f} ] "
                f"[ Slippage: {slippage_pct:5.1f}% → {slippage_pts:5.2f} ]"
            )
            logger.debug(
                "MARKET    | "
                f"{market_points:5.2f} "
                f"[ Volatility: {volatility_pct:5.1f}% → {volatility_pts:5.2f} ] "
                f"[ Volume: {volume_pct:5.1f}% → {volume_pts:5.2f} ] "
                f"[ Price: {price_pct:5.1f}% → {price_pts:5.2f} ]"
            )
            logger.debug(
                "TRADING   | "
                f"{trading_points:5.2f} "
                f"[ Fee: {fee_pct:5.1f}% → {fee_pts:5.2f} ] "
                f"[ Execution: {exec_pct:5.1f}% → {exec_pts:5.2f} ] "
                f"[ Impact: {impact_pct:5.1f}% → {impact_pts:5.2f} ]"
            )
            logger.debug(f"MODIFIER  | imbalance={imbalance_score:.1f}% → +{opportunity_boost:.2f} pts")
            logger.debug(f"TOTAL     | base={base_score:.2f}  final={total_score:.2f}")
            """
            
            return {
                'total_score': total_score,                   # 0..105
                'base_score': base_score,                     # 0..100
                'opportunity_boost': opportunity_boost,       # 0..5
                'category_scores': scores,                    # per-category pts
                'category_breakdown': category_breakdown,     # detailed
                'grade': self._score_to_grade(total_score),
                'passed': total_score >= MIN_LIQUIDITY_SCORE,
            }

        except Exception as e:
            logger.error(f"❌ Error scoring {symbol}: {e}")
            return {
                'total_score': 0,
                'base_score': 0,
                'opportunity_boost': 0,
                'category_scores': {},
                'category_breakdown': {},
                'grade': 'F',
                'passed': False
            }


# ── Calculations ──────────────────────────────────────────────────────────
    
    # ── Liquidity Calculations ──────
    
    def _calculate_spread_score(self, symbol: str, client) -> float:
        try:
            orderbook = client.order_book(symbol, depth=2)
            if not orderbook['bids'] or not orderbook['asks']:
                return 0

            best_bid, best_ask = orderbook['bids'][0][0], orderbook['asks'][0][0]
            mid_price = (best_bid + best_ask) / 2
            spread_pct = (best_ask - best_bid) / mid_price

            # Tight spread = high score (0.1% spread = 100, 1% spread = 0)
            ideal_spread = 0.001  # 0.1%
            max_acceptable = 0.01  # 1%

            if spread_pct <= ideal_spread:
                return 100
            elif spread_pct >= max_acceptable:
                return 0
            else:
                return 100 * (1 - (spread_pct - ideal_spread) / (max_acceptable - ideal_spread))

        except Exception:
            return 0

    def _calculate_depth_score(self, symbol: str, client) -> float:
        try:
            orderbook = client.order_book(symbol, depth=10)
            if not orderbook['bids'] or not orderbook['asks']:
                return 0

            # Calculate total depth in USD for top 10 levels
            mid_price = (orderbook['bids'][0][0] + orderbook['asks'][0][0]) / 2
            bid_depth = sum(amount for price, amount in orderbook['bids'][:10])
            ask_depth = sum(amount for price, amount in orderbook['asks'][:10])
            total_depth = (bid_depth + ask_depth) * mid_price

            # Score based on depth (100 = $100k+, 0 = $0)
            min_depth = 0
            max_depth = 100000  # $100k
            return min(100, 100 * (total_depth - min_depth) / (max_depth - min_depth))

        except Exception:
            return 0

    def _calculate_slippage_score(self, symbol: str, client) -> float:
        try:
            orderbook = client.order_book(symbol, depth=20)
            if not orderbook['bids'] or not orderbook['asks']:
                return 0

            # Calculate slippage for a $10k order
            order_size = 10000
            mid_price = (orderbook['bids'][0][0] + orderbook['asks'][0][0]) / 2

            # Simulate buy order slippage
            filled = 0
            avg_buy_price = 0
            for price, amount in orderbook['asks']:
                fill_amount = min(amount, (order_size - filled) / price)
                avg_buy_price += fill_amount * price
                filled += fill_amount
                if filled * price >= order_size:
                    break

            buy_slippage = (avg_buy_price / filled - mid_price) / mid_price if filled > 0 else 0

            # Score based on slippage (0% = 100, 2% = 0)
            max_slippage = 0.02  # 2%
            return max(0, 100 * (1 - buy_slippage / max_slippage))

        except Exception:
            return 0
        
    # ── Market Calculations ──────
    
    def _calculate_volatility_score(self, symbol: str, client, historical_data=None) -> float:
        try:
            if not historical_data:
                historical_data = client.historical_ohlcv(symbol, "1h", 24)

            if len(historical_data) < 12:  # Need at least 12 hours of data
                return 50  # Neutral score

            closing_prices = [float(candle[2]) for candle in historical_data if float(candle[2]) > 0]
            if len(closing_prices) < 2:
                return 50

            returns = np.diff(closing_prices) / closing_prices[:-1]
            volatility = float(np.std(returns))

            # Score: 0% volatility = 100, 5% volatility = 0
            ideal_volatility = 0.00
            max_volatility = 0.05  # 5%

            if volatility <= ideal_volatility:
                return 100
            elif volatility >= max_volatility:
                return 0
            else:
                return 100 * (1 - (volatility - ideal_volatility) / (max_volatility - ideal_volatility))

        except Exception:
            return 50  # Neutral on error

    def _calculate_volume_consistency(self, symbol: str, client) -> float:
        try:
            # Get recent volume data (last 24 hours)
            candles = client.historical_ohlcv(symbol, "1h", 24)
            if len(candles) < 12:
                return 50

            volumes = [float(candle[5]) for candle in candles]  # Volume is index 5
            if not any(volumes):
                return 0

            # Calculate coefficient of variation (lower = more consistent)
            mean_volume = np.mean(volumes)
            std_volume = np.std(volumes)
            cv = std_volume / mean_volume if mean_volume > 0 else 1.0

            # Score: 0 CV = 100 (perfect consistency), 1 CV = 0 (high variation)
            return max(0, 100 * (1 - min(cv, 1.0)))

        except Exception:
            return 50

    def _calculate_price_stability(self, symbol: str, client) -> float:
        try:
            # Check for recent large price movements
            trades = client.get_recent_trades(symbol, limit=100)
            if len(trades) < 20:
                return 50

            prices = [float(trade['price']) for trade in trades]
            max_price = max(prices)
            min_price = min(prices)
            price_range = (max_price - min_price) / min_price

            # Score based on price range in recent trades
            # 0% range = 100, 10% range = 0
            max_acceptable_range = 0.10  # 10%
            return max(0, 100 * (1 - min(price_range / max_acceptable_range, 1.0)))

        except Exception:
            return 50
    
    # ── Trading Calculations ──────
    
    def _calculate_fee_efficiency(self, symbol: str, client) -> float:
        try:
            fee_info = client.maker_fee(symbol)
            maker_fee = fee_info.get('value', 0.001)  # Default 0.1%

            # Score: 0% fee = 100, 0.2% fee = 0
            ideal_fee = 0.00
            max_fee = 0.002  # 0.2%

            if maker_fee <= ideal_fee:
                return 100
            elif maker_fee >= max_fee:
                return 0
            else:
                return 100 * (1 - (maker_fee - ideal_fee) / (max_fee - ideal_fee))

        except Exception:
            return 50

    def _calculate_execution_speed(self, symbol: str, client) -> float:
        try:
            trades = client.get_recent_trades(symbol, limit=50)
            if len(trades) < 10:
                return 30  # Low activity = poor execution

            # More trades = better liquidity = faster execution
            trade_count = len(trades)
            return min(100, trade_count * 2)  # 50 trades = 100 score

        except Exception:
            return 50

    def _calculate_market_impact(self, symbol: str, client) -> float:
        try:
            orderbook = client.order_book(symbol, depth=5)
            if not orderbook['bids'] or not orderbook['asks']:
                return 0

            # Estimate impact of a $1000 order
            order_size = 1000
            mid_price = (orderbook['bids'][0][0] + orderbook['asks'][0][0]) / 2

            # Calculate price impact on ask side
            filled = 0
            total_cost = 0
            for price, amount in orderbook['asks']:
                fill_amount = min(amount, (order_size - filled) / price)
                total_cost += fill_amount * price
                filled += fill_amount
                if filled * price >= order_size:
                    break

            avg_price = total_cost / filled if filled > 0 else mid_price
            impact = (avg_price - mid_price) / mid_price

            # Score: 0% impact = 100, 1% impact = 0
            return max(0, 100 * (1 - min(impact / 0.01, 1.0)))

        except Exception:
            return 50
    
    # ── Opportunity Mod Calculations ──────

    def _calculate_order_book_imbalance(self, symbol: str, client) -> float:
        try:
            orderbook = client.order_book(symbol, depth=10)
            if not orderbook['bids'] or not orderbook['asks']:
                return 0

            bid_depth = sum(amount for price, amount in orderbook['bids'][:10])
            ask_depth = sum(amount for price, amount in orderbook['asks'][:10])

            ratio = max(bid_depth, ask_depth) / min(bid_depth, ask_depth)

            if 1.0 <= ratio <= 1.5:
                return 50     # Balanced
            elif 1.5 < ratio <= 3.0:
                return 75     # Moderate imbalance = opportunity
            elif 3.0 < ratio <= 5.0:
                return 25     # Concerning imbalance
            else:
                return 0      # Extreme imbalance = avoid

        except Exception:
            return 0

    def _score_to_grade(self, score: float) -> str:
        if score >= 90: return 'A+'
        elif score >= 85: return 'A'
        elif score >= 80: return 'A-'
        elif score >= 75: return 'B+'
        elif score >= 70: return 'B'
        elif score >= 65: return 'B-'
        elif score >= 60: return 'C+'
        elif score >= 50: return 'C'
        elif score >= 40: return 'D'
        else: return 'F'

================================================================================
FILE: mm/conn/conn_kucoin.py
================================================================================
#>> 🍁 A R I A N D E [v 6.1]
#>> last update: 2025 | Sept. 3                ✅ PRODUCTION READY
#>>
#>> KuCoin API Access
#>> mm/conn/conn_kucoin.py
#>>
#>> Live trading client for Ariadne
#>> Proxy connection required due to georestrictions by KuCoin
#>>
#>> Auth'd -> Commander
#>>
#>> [520] [741] [8]
#>>────────────────────────────────────────────────────────────────

# Build|20250903.01

import os
import time
import json
import hmac
import base64
import hashlib
import requests
from dotenv import load_dotenv
from urllib.parse import urlencode

import logging
logger = logging.getLogger("Ariadne")

# ── Config ─────────────────────────────────────────────────────────────

load_dotenv("mm/data/secrets/.env")

API_KEY        = os.getenv("KUCOIN_API", "")
API_SECRET     = os.getenv("KUCOIN_SEC", "")
API_PASSPHRASE = os.getenv("KUCOIN_PASSPHRASE", "")
PROX_USR       = os.getenv("PROXY_USERNAME", "")
PROX_PWD       = os.getenv("PROXY_PASSWORD", "")
PROX_HOST      = os.getenv("PROXY_HOST", "")

BASE_URL       = "https://api.kucoin.com"
FUTURES_URL    = "https://api-futures.kucoin.com"

PROXY_CONFIG = {
   "http":  f"socks5://{PROX_USR}:{PROX_PWD}@{PROX_HOST}",
   "https": f"socks5h://{PROX_USR}:{PROX_PWD}@{PROX_HOST}"
}

FALLBACK = {
    "maker": 0.0010,
    "taker": 0.0010,
    "withdrawal": 0.25,  # placeholder; KuCoin needs /currencies per chain
}

# ── Signing ────────────────────────────────────────────────────────────

class KcSigner:
    def __init__(self, api_key: str, api_secret: str, api_passphrase: str):
        self.api_key = api_key
        self.api_secret = api_secret
        self.api_passphrase = api_passphrase
        self.encrypted_passphrase = self._sign_bytes(
            api_passphrase.encode("utf-8"), api_secret.encode("utf-8")
        )

    def _sign_bytes(self, plain: bytes, key: bytes) -> str:
        hm = hmac.new(key, plain, hashlib.sha256)
        return base64.b64encode(hm.digest()).decode()

    def headers(self, payload_string: str) -> dict:
        ts = str(int(time.time() * 1000))
        sig = self._sign_bytes((ts + payload_string).encode("utf-8"), self.api_secret.encode("utf-8"))
        return {
            "KC-API-KEY": self.api_key,
            "KC-API-SIGN": sig,
            "KC-API-TIMESTAMP": ts,
            "KC-API-PASSPHRASE": self.encrypted_passphrase,
            "KC-API-KEY-VERSION": "2",
            "Content-Type": "application/json",
        }

_signer = KcSigner(API_KEY, API_SECRET, API_PASSPHRASE)

# ── Core request ───────────────────────────────────────────────────────

def kucoin_request(method: str, path: str, params: dict = None, body: dict = None, timeout: int = 10):
    """
    Signs and sends a KuCoin REST request.
    Returns: (json_dict, latency_ms)
    """
    method = method.upper()
    session = requests.Session()
    session.proxies = PROXY_CONFIG

    # Build URL + query
    url = BASE_URL + path
    raw_url = path
    query = ""
    if method in ("GET", "DELETE") and params:
        query = urlencode(params)
        url += f"?{query}"
        raw_url += f"?{query}"

    # Body
    body_str = ""
    data_to_send = None
    if method in ("POST", "PUT") and body:
        body_str = json.dumps(body, separators=(",", ":"))
        data_to_send = body_str

    # KuCoin sign string is: method + endpoint(+query) + body (timestamp prefixed in header builder)
    payload = method + raw_url + body_str

    # Prepare
    req = requests.Request(method, url, data=data_to_send)
    prepped = req.prepare()

    # Headers (GET/DELETE should not send Content-Type)
    hdrs = _signer.headers(payload)
    if method in ("GET", "DELETE"):
        hdrs.pop("Content-Type", None)
    prepped.headers.update(hdrs)

    # Send
    resp = session.send(prepped, timeout=timeout)
    # Return JSON regardless of HTTP code; KuCoin embeds code in JSON
    return resp.json(), int(resp.elapsed.total_seconds() * 1000)

# Convenience alias used by your tests
def kucoin_auth(method: str, path: str, params: dict = None, body: dict = None, timeout: int = 10):
    return kucoin_request(method, path, params, body, timeout)

# ── Client ─────────────────────────────────────────────────────────────

class KucoinClient:
    def __init__(self):
        self._symbols = {}  # "BTC-USDT" -> "BTC-USDT"
        data, _ = kucoin_auth("GET", "/api/v1/symbols")
        for itm in data.get("data", []):
            pair_norm = f"{itm['baseCurrency']}-{itm['quoteCurrency']}".upper()
            self._symbols[pair_norm] = itm["symbol"]

    def list_products(self):
        return list(self._symbols.keys())

    def _pair(self, symbol: str) -> str:
        return self._symbols.get(symbol.upper(), symbol.upper())

    # ── Public Market Data ────────────────────────────────────────────

    def get_all_tickers(self):
        """Get all ticker data in one batch API call"""
        try:
            d, _ = kucoin_auth("GET", "/api/v1/market/allTickers")
            return d.get('data', {}).get('ticker', [])
        except Exception as e:
            logger.error(f"Error fetching batch tickers: {e}")
            return []

    def best_bid_price(self, symbol: str) -> float:
        try:
            d, _ = kucoin_auth("GET", "/api/v1/market/orderbook/level1", {"symbol": self._pair(symbol)})
            return float((d.get("data") or {}).get("bestBid", 0.0))
        except Exception:
            return 0.0

    def best_ask_price(self, symbol: str) -> float:
        try:
            d, _ = kucoin_auth("GET", "/api/v1/market/orderbook/level1", {"symbol": self._pair(symbol)})
            return float((d.get("data") or {}).get("bestAsk", 0.0))
        except Exception:
            return 0.0

    def last_trade_price(self, symbol: str) -> float:
        try:
            d, _ = kucoin_auth("GET", "/api/v1/market/orderbook/level1", {"symbol": self._pair(symbol)})
            return float((d.get("data") or {}).get("price", 0.0))
        except Exception:
            return 0.0

    def vol_24h(self, symbol: str) -> float:
        try:
            d, _ = kucoin_auth("GET", "/api/v1/market/stats", {"symbol": self._pair(symbol)})
            return float((d.get("data") or {}).get("vol", 0.0))
        except Exception:
            return 0.0

    def high_24h(self, symbol: str) -> float:
        try:
            d, _ = kucoin_auth("GET", "/api/v1/market/stats", {"symbol": self._pair(symbol)})
            return float((d.get("data") or {}).get("high", 0.0))
        except Exception:
            return 0.0

    def low_24h(self, symbol: str) -> float:
        try:
            d, _ = kucoin_auth("GET", "/api/v1/market/stats", {"symbol": self._pair(symbol)})
            return float((d.get("data") or {}).get("low", 0.0))
        except Exception:
            return 0.0

    def historical_ohlcv(self, symbol: str, timeframe: str, limit: int):
        """
        Returns KuCoin raw candles: [[time, open, close, high, low, volume, turnover], ...]
        """
        try:
            tf_map = {
                "1m":"1min","3m":"3min","5m":"5min","15m":"15min","30m":"30min",
                "1h":"1hour","2h":"2hour","4h":"4hour","6h":"6hour","8h":"8hour","12h":"12hour",
                "1d":"1day","1w":"1week"
            }
            t = tf_map.get(timeframe, timeframe)

            # derive step seconds
            step = 3600
            if t.endswith("min"):
                step = int(t[:-3]) * 60
            elif t.endswith("hour"):
                step = int(t[:-4]) * 3600
            elif t.endswith("day"):
                step = int(t[:-3]) * 86400
            elif t.endswith("week"):
                step = int(t[:-4]) * 7 * 86400

            now = int(time.time())
            start = now - step * max(1, int(limit))
            params = {"symbol": self._pair(symbol), "type": t, "startAt": start, "endAt": now}
            d, _ = kucoin_auth("GET", "/api/v1/market/candles", params)
            return d.get("data", [])
        except Exception:
            return []

    def order_book(self, symbol: str, depth: int = 10):
        try:
            # level2_20 returns up to 20 each side; we slice to requested depth
            d, _ = kucoin_auth("GET", "/api/v1/market/orderbook/level2_20", {"symbol": self._pair(symbol)})
            data = d.get("data") or {}
            bids = [(float(b[0]), float(b[1])) for b in (data.get("bids") or [])[:depth]]
            asks = [(float(a[0]), float(a[1])) for a in (data.get("asks") or [])[:depth]]
            return {"bids": bids, "asks": asks}
        except Exception:
            return {"bids": [], "asks": []}

    def last_trade(self, symbol: str):
        try:
            d, _ = kucoin_auth("GET", "/api/v1/market/histories", {"symbol": self._pair(symbol)})
            arr = d.get("data") or []
            if not arr:
                return (0, 0.0)
            trade = arr[0]
            ts = int(trade.get("time", 0)) // 1000  # ms -> s
            price = float(trade.get("price", 0.0))
            return (ts, price)
        except Exception:
            return (0, 0.0)

    def intraday_volume(self, symbol: str, interval: str = "ONE_MINUTE", limit: int = 5):
        try:
            interval_map = {
                "ONE_MINUTE": "1min",
                "FIVE_MINUTE": "5min",
                "FIFTEEN_MINUTE": "15min",
                "ONE_HOUR": "1hour",
            }
            k_interval = interval_map.get(interval.upper(), "1min")
            d, _ = kucoin_auth("GET", "/api/v1/market/candles", {
                "symbol": self._pair(symbol),
                "type": k_interval
            })
            candles = d.get("data", [])
            # [time, open, close, high, low, volume, turnover]
            vol_data = [(str(int(c[0]) // 1000), float(c[5])) for c in candles[:limit]]
            return list(reversed(vol_data))
        except Exception:
            return []

    # ── Private / Fees / Limits ───────────────────────────────────────

    def maker_fee(self, symbol: str = None):
        """
        Fetch maker fee from KuCoin. Returns {"source":"api|fallback","value":float}.
        """
        try:
            params = {"symbols": self._pair(symbol)} if symbol else None
            d, _ = kucoin_auth("GET", "/api/v1/trade-fees", params)
            if d.get("code") == "200000" and d.get("data"):
                row = d["data"][0] or {}
                val = float(row.get("makerFeeRate"))
                # If API returns 0 or missing, treat as error → fallback
                if val > 0:
                    return {"source": "api", "value": val}
            # explicit soft-error → fallback
            return {"source": "fallback", "value": FALLBACK["maker"]}
        except Exception:
            return {"source": "fallback", "value": FALLBACK["maker"]}


    def taker_fee(self, symbol: str = None):
        """
        Fetch taker fee from KuCoin. Returns {"source":"api|fallback","value":float}.
        """
        try:
            params = {"symbols": self._pair(symbol)} if symbol else None
            d, _ = kucoin_auth("GET", "/api/v1/trade-fees", params)
            if d.get("code") == "200000" and d.get("data"):
                row = d["data"][0] or {}
                val = float(row.get("takerFeeRate"))
                if val > 0:
                    return {"source": "api", "value": val}
            return {"source": "fallback", "value": FALLBACK["taker"]}
        except Exception:
            return {"source": "fallback", "value": FALLBACK["taker"]}


    def withdrawal_fee(self, symbol: str, network: str = None):
        """
        Always fetch XRP withdraw fee (your policy). Returns fee in XRP units.
        Uses KuCoin currencies endpoint and picks the XRP/XRPL chain row.
        """
        try:
            # v3 endpoint returns one object with 'chains' list
            d, _ = kucoin_auth("GET", "/api/v3/currencies/XRP")
            data = d.get("data") or {}

            # 'chains' might be list under either data['chains'] or data (older)
            chains = data.get("chains")
            if chains is None and isinstance(data, list):
                chains = data
            if not chains:
                return {"source": "fallback", "value": FALLBACK["withdrawal"], "network": "XRP"}

            fee_val = None
            for ch in chains:
                name = (ch.get("chain") or ch.get("name") or "").upper()
                if name in ("XRP", "XRPL", "RIPPLE"):
                    # Key names vary by doc/version: withdrawFee / withdrawMinFee / withdrawalMinFee
                    raw = ch.get("withdrawFee", ch.get("withdrawMinFee", ch.get("withdrawalMinFee")))
                    if raw is not None:
                        fee_val = float(raw)
                        break

            # If we didn't find an explicit XRP row, take the smallest withdraw fee among chains
            if fee_val is None:
                fees = []
                for ch in chains:
                    raw = ch.get("withdrawFee", ch.get("withdrawMinFee", ch.get("withdrawalMinFee")))
                    if raw is not None:
                        try: fees.append(float(raw))
                        except: pass
                if fees:
                    fee_val = min(fees)
                    return {"source": "api", "value": fee_val, "network": "XRP"}
                return {"source": "fallback", "value": FALLBACK["withdrawal"], "network": "XRP"}

            return {"source": "api", "value": fee_val, "network": "XRP"}

        except Exception:
            return {"source": "fallback", "value": FALLBACK["withdrawal"], "network": "XRP"}

    def min_trade_size(self, symbol: str):
        try:
            d, _ = kucoin_auth("GET", "/api/v1/symbols")
            ex = self._pair(symbol).upper()
            for itm in d.get("data", []):
                if itm.get("symbol", "").upper() == ex:
                    v = float(itm.get("baseMinSize", 0.0))
                    return {"source": "api", "value": v}
            return {"source": "fallback", "value": 0.0}
        except Exception:
            return {"source": "fallback", "value": 0.0}
        
    def get_recent_trades(self, symbol: str, limit: int = 100):
        """
        Fetches recent trades for a symbol.
        Args:
            symbol: The trading pair (e.g., 'BTC-USDT')
            limit: Number of trades to fetch (max 100)
        Returns:
            list: A list of recent trades, newest first.
        """
        try:
            params = {"symbol": self._pair(symbol)}
            d, _ = kucoin_auth("GET", "/api/v1/market/histories", params)
            return d.get('data', [])[:limit]
        except Exception as e:
            logger.error(f"Error fetching recent trades for {symbol}: {e}")
            return []

    # ── Wallet Functions  ─────────────────────────────────────────────
    def get_account_balances(self, account_type: str = "trade"):
        try:
            # Use the private API endpoint for accounts
            params = {"type": account_type}
            d, _ = kucoin_auth("GET", "/api/v1/accounts", params)
            
            balances = {}
            if d.get("code") == "200000":
                for account in d.get("data", []):
                    currency = (account.get("currency") or "").upper()
                    # Only count available balance, not held
                    available = float(account.get("available", 0.0))
                    if available > 0:
                        balances[currency] = balances.get(currency, 0.0) + available
            return balances
        except Exception as e:
            # Log the error and return an empty dict to avoid crashing the bot
            logger.error(f"Error fetching balances: {e}")
            return {}
        
    def get_account_balances_detailed(self, account_type: str = "trade"):
        """
        Returns { 'USDT': {'available': x, 'hold': y}, 'BTC': {...}, ... }
        Uses KuCoin accounts endpoint.
        """
        try:
            params = {"type": account_type}
            d, _ = kucoin_auth("GET", "/api/v1/accounts", params)
            balances = {}
            if d.get("code") == "200000":
                for acc in d.get("data", []):
                    currency = (acc.get("currency") or "").upper()
                    if not currency:
                        continue
                    available = float(acc.get("available", 0.0) or 0.0)
                    hold = float(acc.get("hold", acc.get("holds", 0.0) or 0.0) or 0.0)
                    cur = balances.get(currency, {"available": 0.0, "hold": 0.0})
                    cur["available"] += max(0.0, available)
                    cur["hold"] += max(0.0, hold)
                    balances[currency] = cur
            return balances
        except Exception as e:
            logger.error(f"Error fetching detailed balances: {e}")
            return {}
    
    def get_orders(self, symbol: str = None, status: str = "active"):
        """Get orders from exchange."""
        endpoint = "/api/v1/orders"
        params = {"status": status}
        if symbol:
            params["symbol"] = symbol
        return self._get(endpoint, params)
    
    def get_open_sells(self):
        params = {
            "status": "active",
            "side": "sell"
        }
        d, _ = kucoin_auth("GET", "/api/v1/orders", params=params)
        return d
    
    def get_open_buys(self):
        params = {
            "status": "active",
            "side": "buy"
        }
        d, _ = kucoin_auth("GET", "/api/v1/orders", params=params)
        return d

    # ── Orders ────────────────────────────────────────────────────────

    def create_limit_order(self, symbol: str, side: str, price: float, size: float,
                           post_only: bool = False, tif: str = "GTC",
                           hidden: bool = False, iceberg: bool = False) -> str:
        """
        Places a limit order; returns orderId on success, raises on error.
        """
        path = "/api/v1/orders"
        body = {
            "clientOid": str(int(time.time() * 1000)),
            "symbol": self._pair(symbol),
            "side": side.lower(),   # "buy"/"sell"
            "type": "limit",
            "price": str(round(float(price), 8)),
            "size": str(round(float(size), 8)),
            "timeInForce": tif,
            "postOnly": bool(post_only),
            "hidden": bool(hidden),
            "iceberg": bool(iceberg),
        }
        data, _ = kucoin_auth("POST", path, None, body)
        if data.get("code") == "200000":
            od = data.get("data") or {}
            if "orderId" in od:
                return str(od["orderId"])
        raise ValueError(f"Unexpected KuCoin response: {data}")

    def get_order(self, order_id: str):
        d, _ = kucoin_auth("GET", f"/api/v1/orders/{order_id}")
        return d

    def cancel_order(self, order_id: str):
        d, _ = kucoin_auth("DELETE", f"/api/v1/orders/{order_id}")
        return d
    
    def create_market_order(self, symbol: str, side: str, size: float) -> str:
        """
        Places a market order.
        Args:
            symbol: The trading pair (e.g., 'BTC-USDT')
            side: 'buy' or 'sell'
            size: The amount of the base currency to buy/sell
        Returns:
            str: The order ID from KuCoin
        Raises:
            ValueError: If the order placement fails.
        """
        path = "/api/v1/orders"
        body = {
            "clientOid": str(int(time.time() * 1000)),
            "symbol": self._pair(symbol),
            "side": side.lower(),
            "type": "market",
            "size": str(round(float(size), 8)),
        }
        data, _ = kucoin_auth("POST", path, None, body)
        if data.get("code") == "200000":
            od = data.get("data") or {}
            if "orderId" in od:
                return str(od["orderId"])
        raise ValueError(f"Failed to place market order: {data}")

    # ── Futures (funding rate helper) ─────────────────────────────────

    def funding_rate(self, symbol: str) -> float:
        """
        Maps spot symbol like BTC-USDT to futures perpetual (e.g., XBTUSDTM or BTCUSDTM-PERP),
        then fetches current funding rate. Best-effort; returns 0.0 if not found.
        """
        try:
            # Fetch active contracts via same proxy
            r = requests.get(f"{FUTURES_URL}/api/v1/contracts/active", timeout=10, proxies=PROXY_CONFIG)
            r.raise_for_status()
            contracts = r.json().get("data", [])

            base = symbol.split("-")[0].upper()

            fut_symbol = None
            for c in contracts:
                s = (c.get("symbol") or "").upper()
                # heuristics: endswith PERP; name formats differ
                if s.startswith(base) and "PERP" in s:
                    fut_symbol = c.get("symbol")
                    break

            if not fut_symbol:
                return 0.0

            r2 = requests.get(f"{FUTURES_URL}/api/v1/funding-rate/{fut_symbol}", timeout=10, proxies=PROXY_CONFIG)
            r2.raise_for_status()
            data = r2.json().get("data") or {}
            return float(data.get("fundingRate", 0.0))
        except Exception:
            return 0.0


# ── Public helpers ─────────────────────────────────────────────────────

def public_products():
    d, _ = kucoin_auth("GET", "/api/v1/symbols")
    return [item["symbol"] for item in d.get("data", [])]

def test_proxy_connection():
    try:
        test_url = "https://api.infoip.io/"
        resp = requests.get(test_url, proxies=PROXY_CONFIG, timeout=10)
        ip_info = resp.json()
        country = ip_info.get("country", "unknown")
        logger.info("Proxy test successful. Connection from: %s", country)
        return True
    except Exception as e:
        # Include traceback so you can see DNS/proxy errors in logs
        logger.critical("Proxy test failed: %s", e, exc_info=True)
        return False

================================================================================
FILE: mm/conn/sim_kucoin.py
================================================================================
#>> 🍁 A R I A N D E [v 6.1]
#>> last update: 2025 | Sept. 2                ✅ PRODUCTION READY
#>>
#>> simulation client
#>> mm/conn/sim_kucoin.py
#>>
#>> Simulation client that mimics KucoinClient interface. 
#>> Uses live market data + simulated wallet/orders 
#>> Virtual 'paper trading'   
#>>
#>> Auth'd -> Commander
#>>
#>> [520] [741] [8]
#>>────────────────────────────────────────────────────────────────

# Build|20250902.01

import logging
import time
import threading
from typing import Dict, Optional, Tuple, List
from decimal import Decimal, ROUND_DOWN
import psycopg2
import psycopg2.extras

# Import the live client for market data
from mm.conn.conn_kucoin import KucoinClient
from mm.config.marcus import SIMULATION_DB_PATH  # For compatibility, though we use PostgreSQL

logger = logging.getLogger("ariadne.sim")

# ---- DB Connection -----------------------------------------------------------
def get_db_connection():
    """
    Create a PostgreSQL connection to 'ariadne' as postgres@localhost.
    """
    return psycopg2.connect(dbname="ariadne", user="postgres", host="localhost")

# ---- Helpers ----------------------------------------------------------------
D2 = Decimal("0.01")
D8 = Decimal("0.00000001")
ZERO = Decimal("0")

def _q2(x: Decimal) -> Decimal:
    """Quantize to 2 dp (money, human)."""
    return x.quantize(D2, rounding=ROUND_DOWN)

def _q8(x: Decimal) -> Decimal:
    """Quantize to 8 dp (crypto sizes/prices)."""
    return x.quantize(D8, rounding=ROUND_DOWN)

def _split_symbol(symbol: str) -> Tuple[str, str]:
    base, quote = symbol.upper().split("-", 1)
    return base, quote

# ---- Sim Client --------------------------------------------------------------
class SimClient:
    """
    Simulator backed by PostgreSQL tables:
      - tickstick (partitioned): market snapshot source for pricing/fees
      - sim_balances(asset, available, hold)
      - sim_orders(id, symbol, side, price, size, filled_size, status, created_at, updated_at, filled_at, deleted, deleted_at)
      - sim_trades(timestamp, symbol, side, price, size, sim_order_id, fee)
    """
    
    def __init__(self, db_path: str = None, db_lock=None):
        """Initialize with live client for market data and optional db lock for thread safety."""
        # db_path kept for compatibility but ignored (we use PostgreSQL)
        self.db_path = db_path or SIMULATION_DB_PATH
        self.db_lock = db_lock if db_lock else threading.RLock()  # Default to RLock if none provided
        self.live_client = KucoinClient()
        self._symbols = self.live_client._symbols

    # ── Public Market Data (use live data) ────────────────────────────
    
    def get_all_tickers(self):
        """Delegate to live client for real market data."""
        return self.live_client.get_all_tickers()

    def best_bid_price(self, symbol: str) -> float:
        """Use live market data."""
        return self.live_client.best_bid_price(symbol)

    def best_ask_price(self, symbol: str) -> float:
        """Use live market data."""
        return self.live_client.best_ask_price(symbol)

    def last_trade_price(self, symbol: str) -> float:
        """Use live market data."""
        return self.live_client.last_trade_price(symbol)

    def vol_24h(self, symbol: str) -> float:
        """Use live market data."""
        return self.live_client.vol_24h(symbol)

    def high_24h(self, symbol: str) -> float:
        """Use live market data."""
        return self.live_client.high_24h(symbol)

    def low_24h(self, symbol: str) -> float:
        """Use live market data."""
        return self.live_client.low_24h(symbol)

    def historical_ohlcv(self, symbol: str, timeframe: str, limit: int):
        """Use live market data."""
        return self.live_client.historical_ohlcv(symbol, timeframe, limit)

    def order_book(self, symbol: str, depth: int = 10):
        """Use live market data."""
        return self.live_client.order_book(symbol, depth)

    def get_recent_trades(self, symbol: str, limit: int = 100):
        """Use live market data."""
        return self.live_client.get_recent_trades(symbol, limit)

    def list_products(self):
        """Use live market data."""
        return self.live_client.list_products()

    def _pair(self, symbol: str) -> str:
        """Use live client's pair method."""
        return self.live_client._pair(symbol)

    # ── Fees (simple/simulated) ───────────────────────────────────────

    def maker_fee(self, symbol: str = None):
        """Return simulated maker fee."""
        return {"source": "simulation", "value": 0.0010}

    def taker_fee(self, symbol: str = None):
        """Return simulated taker fee."""
        return {"source": "simulation", "value": 0.0010}

    def withdrawal_fee(self, symbol: str, network: str = None):
        """Return simulated withdrawal fee."""
        return {"source": "simulation", "value": 0.25, "network": "XRP"}

    def min_trade_size(self, symbol: str):
        """Get minimum trade size from live client."""
        live_result = self.live_client.min_trade_size(symbol)
        return {"source": "simulation", "value": live_result["value"]}

    # ── Internal fee helper (for PostgreSQL-based fees if needed) ────────
    
    def _get_fees_from_db(self, conn, symbol: str) -> Tuple[float, float]:
        """
        Return (maker, taker) as fractions (e.g., 0.001 = 0.1%).
        Falls back to default 0.0010 if not in tickstick.
        """
        MAKER_KEYS = ("maker_fee", "maker_fee_bps", "maker_bps", "maker_rate", "makerFeeRate")
        TAKER_KEYS = ("taker_fee", "taker_fee_bps", "taker_bps", "taker_rate", "takerFeeRate")
        MAKER_COEFF_KEYS = ("maker_coeff", "maker_coef", "maker_coefficient", "makerCoefficient")
        TAKER_COEFF_KEYS = ("taker_coeff", "taker_coef", "taker_coefficient", "takerCoefficient")

        try:
            cur = conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor)
            cur.execute(
                """
                SELECT *
                FROM tickstick
                WHERE symbol = %s
                ORDER BY timestamp DESC
                LIMIT 1
                """,
                (symbol,),
            )
            row = cur.fetchone() or {}
            cur.close()

            def pick(rr: Dict, keys, default=None):
                for k in keys:
                    if k in rr and rr[k] is not None:
                        try:
                            return float(rr[k])
                        except Exception:
                            continue
                return default

            maker_raw = pick(row, MAKER_KEYS, 0.0010)
            taker_raw = pick(row, TAKER_KEYS, 0.0010)
            m_coeff = pick(row, MAKER_COEFF_KEYS, 1.0)
            t_coeff = pick(row, TAKER_COEFF_KEYS, 1.0)

            # Support bps if raw > 1 (e.g., 10 = 10 bps = 0.0010)
            maker = (maker_raw / 10000.0) if maker_raw > 1 else maker_raw
            taker = (taker_raw / 10000.0) if taker_raw > 1 else taker_raw

            maker *= (m_coeff or 1.0)
            taker *= (t_coeff or 1.0)

            # Clamp to sane range [0, 1%]
            maker = max(0.0, min(maker, 0.01))
            taker = max(0.0, min(taker, 0.01))
            return (maker, taker)
        except Exception:
            return (0.0010, 0.0010)

    # ── Wallet Functions (simulation only) ─────────────────────────────

    def get_account_balances(self, account_type: str = "trade") -> Dict[str, float]:
        """Available balances only (compat with live)."""
        with self.db_lock:
            return self._get_balances()
    
    def _get_balances(self) -> Dict[str, float]:
        """Internal method to get balances (available only)."""
        try:
            with get_db_connection() as conn:
                cur = conn.cursor()
                cur.execute("SELECT asset, available FROM sim_balances")
                balances = {row[0].upper(): float(row[1] or 0.0) for row in cur.fetchall()}
                cur.close()
                return balances
        except Exception as e:
            logger.error(f"Error reading balances: {e}")
            return {}

    def get_account_balances_detailed(self, account_type: str = "trade") -> Dict[str, Dict[str, float]]:
        """Available + hold, mirroring live client detailed call."""
        with self.db_lock:
            return self._get_balances_detailed()
    
    def _get_balances_detailed(self) -> Dict[str, Dict[str, float]]:
        """Internal method to get detailed balances."""
        try:
            with get_db_connection() as conn:
                cur = conn.cursor()
                cur.execute("SELECT asset, available, hold FROM sim_balances")
                result = {}
                for asset, available, hold in cur.fetchall():
                    result[asset.upper()] = {
                        "available": float(available or 0.0),
                        "hold": float(hold or 0.0)
                    }
                cur.close()
                return result
        except Exception as e:
            logger.error(f"Error fetching detailed balances: {e}")
            return {}

    def _update_balance(self, currency: str, delta_available: float = 0.0, delta_hold: float = 0.0):
        """Adjust available/hold for a currency."""
        with self.db_lock:
            self._update_balance_internal(currency, delta_available, delta_hold)
    
    def _update_balance_internal(self, currency: str, delta_available: float, delta_hold: float):
        """Internal method to update balance."""
        currency = currency.upper()
        try:
            with get_db_connection() as conn:
                cur = conn.cursor()
                # Ensure row exists
                cur.execute(
                    "INSERT INTO sim_balances (asset, available, hold) VALUES (%s, 0, 0) ON CONFLICT (asset) DO NOTHING",
                    (currency,)
                )
                
                # Update balances
                cur.execute(
                    """
                    UPDATE sim_balances 
                    SET available = GREATEST(0, available + %s),
                        hold = GREATEST(0, hold + %s)
                    WHERE asset = %s
                    """,
                    (delta_available, delta_hold, currency)
                )
                conn.commit()
                cur.close()
        except Exception as e:
            logger.error(f"Error updating balance for {currency}: {e}")
            raise

    def _get_balance_row(self, currency: str) -> Tuple[float, float]:
        """Get balance row with lock support."""
        with self.db_lock:
            return self._get_balance_row_internal(currency)
    
    def _get_balance_row_internal(self, currency: str) -> Tuple[float, float]:
        """Internal method to get balance row."""
        currency = currency.upper()
        try:
            with get_db_connection() as conn:
                cur = conn.cursor()
                cur.execute("SELECT available, hold FROM sim_balances WHERE asset = %s", (currency,))
                row = cur.fetchone()
                cur.close()
                return (float(row[0]), float(row[1])) if row else (0.0, 0.0)
        except Exception:
            return (0.0, 0.0)

    # ── Orders (simulation only) ─────────────────────────────────────

    def create_limit_order(
        self,
        symbol: str,
        side: str,
        price: float,
        size: float,
        post_only: bool = False,
        tif: str = "GTC",
        hidden: bool = False,
        iceberg: bool = False,
    ) -> str:
        """Place a simulated limit order. Applies/creates holds atomically."""
        with self.db_lock:
            return self._create_limit_order_internal(symbol, side, price, size, post_only, tif, hidden, iceberg)
    
    def _create_limit_order_internal(
        self,
        symbol: str,
        side: str,
        price: float,
        size: float,
        post_only: bool,
        tif: str,
        hidden: bool,
        iceberg: bool
    ) -> str:
        """Internal method to create limit order."""
        side = side.lower()
        if side not in ("buy", "sell"):
            raise ValueError("side must be 'buy' or 'sell'")

        order_id = f"SIM_{side.upper()}_{int(time.time() * 1000)}"
        base, quote = _split_symbol(symbol)

        d_price = _q8(Decimal(str(price)))
        d_size = _q8(Decimal(str(size)))

        try:
            with get_db_connection() as conn:
                cur = conn.cursor()

                # Ensure balance rows exist
                cur.execute("INSERT INTO sim_balances (asset, available, hold) VALUES (%s, 0, 0) ON CONFLICT (asset) DO NOTHING", (quote,))
                cur.execute("INSERT INTO sim_balances (asset, available, hold) VALUES (%s, 0, 0) ON CONFLICT (asset) DO NOTHING", (base,))

                if side == "buy":
                    # Hold quote equal to notional
                    notional = float(_q8(d_price * d_size))
                    
                    # Check available balance
                    cur.execute("SELECT available FROM sim_balances WHERE asset = %s", (quote,))
                    row = cur.fetchone()
                    available = float(row[0]) if row else 0.0
                    
                    if available < notional:
                        raise ValueError(
                            f"Insufficient {quote} available to place BUY hold: need {notional:.8f}, have {available:.8f}"
                        )
                    
                    cur.execute(
                        """
                        UPDATE sim_balances
                        SET available = available - %s,
                            hold = hold + %s
                        WHERE asset = %s
                        """,
                        (notional, notional, quote)
                    )
                else:
                    # Hold base units equal to size
                    size_float = float(d_size)
                    
                    # Check available balance
                    cur.execute("SELECT available FROM sim_balances WHERE asset = %s", (base,))
                    row = cur.fetchone()
                    available = float(row[0]) if row else 0.0
                    
                    if available < size_float:
                        raise ValueError(
                            f"Insufficient {base} available to place SELL hold: need {size_float:.8f}, have {available:.8f}"
                        )
                    
                    cur.execute(
                        """
                        UPDATE sim_balances
                        SET available = available - %s,
                            hold = hold + %s
                        WHERE asset = %s
                        """,
                        (size_float, size_float, base)
                    )

                # Insert order row
                cur.execute(
                    """
                    INSERT INTO sim_orders (id, symbol, side, price, size, filled_size, status, created_at, updated_at)
                    VALUES (%s, %s, %s, %s, %s, %s, 'open', NOW(), NOW())
                    """,
                    (order_id, symbol, side, float(d_price), float(d_size), 0.0)
                )

                conn.commit()
                cur.close()
                logger.info(f"[ORDER] Created {side} {d_size} {symbol} @ {d_price} (id {order_id})")
                return order_id
        except Exception as e:
            logger.error(f"[ERROR] create_limit_order failed: {e}")
            raise

    def create_market_order(self, symbol: str, side: str, size: float) -> str:
        """Simulate market order placement using current best price. Abort if price is 0."""
        price = self.best_ask_price(symbol) if side.lower() == "buy" else self.best_bid_price(symbol)
        price = float(price or 0.0)
        if price <= 0.0:
            raise ValueError(f"Cannot place market {side} for {symbol}: no valid price (got {price}).")
        return self.create_limit_order(symbol, side, price, size)

    def cancel_order(self, order_id: str) -> Dict:
        """Cancel an open/partial order and release remaining holds."""
        with self.db_lock:
            return self._cancel_order_internal(order_id)
    
    def _cancel_order_internal(self, order_id: str) -> Dict:
        """Internal method to cancel order."""
        try:
            with get_db_connection() as conn:
                cur = conn.cursor()
                
                # Lock the order row
                cur.execute(
                    """
                    SELECT symbol, side, price, size, COALESCE(filled_size,0)
                    FROM sim_orders
                    WHERE id = %s
                    FOR UPDATE
                    """,
                    (order_id,)
                )
                r = cur.fetchone()
                
                if not r:
                    cur.close()
                    return {"code": "400000", "msg": "Order not found"}

                symbol, side, price, size, filled = r
                base, quote = _split_symbol(symbol)
                d_price = Decimal(str(price))
                d_size = Decimal(str(size))
                d_filled = Decimal(str(filled))
                remaining_qty = max(ZERO, d_size - d_filled)

                if side == "buy":
                    remaining_notional = float(_q8(d_price * remaining_qty))
                    # Release quote hold: hold -> available
                    cur.execute(
                        """
                        UPDATE sim_balances
                        SET available = available + %s,
                            hold = GREATEST(hold - %s, 0)
                        WHERE asset = %s
                        """,
                        (remaining_notional, remaining_notional, quote)
                    )
                else:
                    # Release base hold: hold -> available
                    remaining_float = float(remaining_qty)
                    cur.execute(
                        """
                        UPDATE sim_balances
                        SET available = available + %s,
                            hold = GREATEST(hold - %s, 0)
                        WHERE asset = %s
                        """,
                        (remaining_float, remaining_float, base)
                    )

                # Soft delete + status
                cur.execute(
                    """
                    UPDATE sim_orders
                    SET status = 'cancelled',
                        updated_at = NOW(),
                        deleted = TRUE,
                        deleted_at = NOW()
                    WHERE id = %s
                    """,
                    (order_id,)
                )

                conn.commit()
                cur.close()
                logger.info(f"[CANCEL] Order {order_id} cancelled; holds released.")
                return {"code": "200000", "data": {"cancelledOrderId": order_id}}
        except Exception as e:
            logger.error(f"[ERROR] cancel_order failed: {e}")
            return {"code": "400000", "msg": "Cancel failed"}

    def get_order(self, order_id: str) -> Dict:
        """Get simulated order details."""
        with self.db_lock:
            return self._get_order_internal(order_id)
    
    def _get_order_internal(self, order_id: str) -> Dict:
        """Internal method to get order."""
        try:
            with get_db_connection() as conn:
                cur = conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor)
                cur.execute(
                    """
                    SELECT id, symbol, side, price, size, filled_size, status, created_at, updated_at, filled_at, deleted, deleted_at
                    FROM sim_orders
                    WHERE id = %s
                    """,
                    (order_id,)
                )
                row = cur.fetchone()
                cur.close()
                
                if not row:
                    return {"code": "400000", "msg": "Order not found"}
                
                data = {
                    "id": row["id"],
                    "symbol": row["symbol"],
                    "side": row["side"],
                    "price": float(row["price"]),
                    "size": float(row["size"]),
                    "filledSize": float(row["filled_size"] or 0.0),
                    "status": row["status"],
                }
                return {"code": "200000", "data": data}
        except Exception as e:
            logger.error(f"Error getting order {order_id}: {e}")
            return {"code": "400000", "msg": "Order not found"}

    # ── Fills (keep the enhanced PostgreSQL version) ─────────────────
    
    def fill_order(self, order_id: str, fill_price: float, fill_qty: float, fee_amount: float = 0.0, role: Optional[str] = None) -> None:
        """
        Execute an order fill atomically:
          - Insert sim_trades
          - Update sim_orders (partial/filled, timestamps, soft-delete on full)
          - Update sim_balances (deduct/add with fee)
        """
        with self.db_lock:
            self._fill_order_internal(order_id, fill_price, fill_qty, fee_amount, role)
    
    def _fill_order_internal(self, order_id: str, fill_price: float, fill_qty: float, fee_amount: float, role: Optional[str]) -> None:
        """Internal method to fill order."""
        try:
            with get_db_connection() as conn:
                cur = conn.cursor()

                # 1) Lock and fetch the order state
                cur.execute(
                    """
                    SELECT status, COALESCE(filled_size,0), size, side, symbol, price
                    FROM sim_orders
                    WHERE id = %s
                    FOR UPDATE
                    """,
                    (order_id,)
                )
                row = cur.fetchone()
                if not row:
                    cur.close()
                    return
                
                status_db, filled_db, size_db, side_db, symbol_db, price_db = row

                if status_db not in ("open", "partial"):
                    cur.close()
                    return

                d_price = _q8(Decimal(str(fill_price)))
                d_qty = _q8(Decimal(str(fill_qty)))
                d_fee = _q8(Decimal(str(fee_amount))) if fee_amount is not None else ZERO

                # Clamp to remaining
                remaining = _q8(Decimal(str(size_db)) - Decimal(str(filled_db)))
                if remaining <= ZERO:
                    cur.close()
                    return
                d_qty = min(d_qty, remaining)

                # 2) Insert trade
                cur.execute(
                    """
                    INSERT INTO sim_trades (timestamp, symbol, side, price, size, sim_order_id, fee)
                    VALUES (NOW(), %s, %s, %s, %s, %s, %s)
                    """,
                    (symbol_db, side_db, float(d_price), float(d_qty), order_id, float(d_fee))
                )

                # 3) Update order
                new_filled = _q8(Decimal(str(filled_db)) + d_qty)
                if new_filled < Decimal(str(size_db)):
                    cur.execute(
                        """
                        UPDATE sim_orders
                        SET filled_size = %s,
                            status = 'partial',
                            updated_at = NOW()
                        WHERE id = %s
                        """,
                        (float(new_filled), order_id)
                    )
                else:
                    cur.execute(
                        """
                        UPDATE sim_orders
                        SET filled_size = size,
                            status = 'filled',
                            filled_at = NOW(),
                            updated_at = NOW(),
                            deleted = TRUE,
                            deleted_at = NOW()
                        WHERE id = %s
                        """,
                        (order_id,)
                    )

                # 4) Balances
                base_asset, quote_asset = symbol_db.split("-")
                notional = _q8(d_price * d_qty)
                
                if side_db == "buy":
                    # BUY: reduce quote hold by filled notional+fee, add base available
                    total_quote = float(_q8(notional + d_fee))
                    cur.execute(
                        """
                        UPDATE sim_balances
                        SET hold = GREATEST(0, hold - %s)
                        WHERE asset = %s
                        """,
                        (total_quote, quote_asset)
                    )
                    cur.execute(
                        """
                        INSERT INTO sim_balances (asset, available, hold)
                        VALUES (%s, %s, 0)
                        ON CONFLICT (asset) DO UPDATE
                        SET available = sim_balances.available + EXCLUDED.available
                        """,
                        (base_asset, float(d_qty))
                    )
                else:
                    # SELL: reduce base hold by filled qty, add quote available (less fee)
                    quote_credit = float(_q8(notional - d_fee))
                    cur.execute(
                        """
                        UPDATE sim_balances
                        SET hold = GREATEST(0, hold - %s)
                        WHERE asset = %s
                        """,
                        (float(d_qty), base_asset)
                    )
                    cur.execute(
                        """
                        UPDATE sim_balances
                        SET available = available + %s
                        WHERE asset = %s
                        """,
                        (quote_credit, quote_asset)
                    )

                conn.commit()
                cur.close()
                logger.info(f"[FILL] {side_db.upper()} {d_qty} {symbol_db} @ {d_price} (fee {d_fee})")
        except Exception as e:
            logger.error(f"[ERROR] fill_order failed: {e}")
            raise

================================================================================
FILE: mm/config/marcus.py
================================================================================
#>> A R I A N D E v6
#>> last update: 2025 | Sept. 4
#>>
#>> Ariadne Config Parameters
#>> mm/config/marcus.py
#>>
#>> Config parameters for the market making bot, Ariadne.
#>> Trading limits & tolerances.
#>> Operation mode toggle.
#>>
#>> Auth'd -> Commander
#>>
#>> [520] [741] [8]
#>>────────────────────────────────────────────────────────────────

# Build|20250904.01

from typing import List

# ── Operational Mode Toggle ─────────────────────────────────────────────────────────────────────
MODE: str = "simulation"
# Options
#>> simulation  | full simulation of live operations.
#>> live        | production environment, real trades, real money.
#>> halted      | no new orders, existing bids/asks are allowed to complete.
#>> drain       | no new orders, existing bids cancelled, positions are liquidated profitable or neutral.
#>> maintenance | trading actions disabled, background processes continue.
#>> shadow      | runs the full decision loop in parallel with live but only logs intents (no orders).
    
# ── Dashboard Progress Bar  ─────────────────────────────────────────────────────────────────────   
SHOW_PROGRESS: bool = False

# ── Paths ───────────────────────────────────────────────────────────────────────────────────────    
SIMULATION_DB_PATH: str = "mm/data/sims/ariadne_sim.db"   
LIVE_DB_PATH: str = "mm/data/live/ariadne_live.db"        
LEDGER_DB_PATH: str = "mm/data/finance/ledger.db"
SIM_STATE_FILE: str = "mm/data/state/sim_state.json"   
LIVE_STATE_FILE: str = "mm/data/state/live_state.json" 

# ── Capital & Risk Management ───────────────────────────────────────────────────────────────────
INITIAL_CAPITAL: float = 2500.0             # USDT
MAX_EXPOSURE_PER_PAIR: float = 0.1          # 10% of total capital
QUOTE_CURRENCY: str = "USDT"
BASE_QUOTE: str = QUOTE_CURRENCY            #For backwards compatibility, can be removed later.
INVENTORY_DRAWDOWN_LIMIT: float = 0.1       # 10% loss on inventory triggers defense
    
# ── Market Making Parameters ────────────────────────────────────────────────────────────────────
TARGET_SPREAD_PCT: float = 0.01             # 1% spread (was 0.002)
MAX_SPREAD_PCT: float = 0.03                # 3% max spread (was 0.01)
MIN_SPREAD_PCT: float = 0.005               # 0.5% minimum spread
    
# ── Order Management ────────────────────────────────────────────────────────────────────────────
ORDER_REFRESH_SECONDS: int = 600            # Cancel and replace orders older than this
MAX_ORDERS_PER_PAIR: int = 2                # Max concurrent orders per side per pair
ORDER_DISTANCE_FROM_MID: float = 0.005      # Minimum 0.5% distance from mid price
    
# ── Position Management ─────────────────────────────────────────────────────────────────────────
MAX_POSITION_AGE_HOURS: int = 4             # Liquidate positions older than this
POSITION_REDUCTION_SPREAD: float = 0.005    # Tighter spread when reducing position
MAX_ASSET_PCT: float = 0.10                 # 10% per-asset cap (share of portfolio value, ex-cash)
CAP_MARGIN:    float = 0.01                 # +1% tolerance band (allows slight overage before hard-deny)
    
# ── Pair Selection ──────────────────────────────────────────────────────────────────────────────
MIN_PAIR_VOLUME_24H: float = 100000         # Minimum 24h volume in USDT
MAX_PAIRS_TO_TRADE: int = 5                 # Focus on top 5 pairs only
PAIR_ROTATION_INTERVAL: int = 300           # Re-evaluate pairs every 5 minutes

# ── Profitability Targets ───────────────────────────────────────────────────────────────────────
TARGET_DAILY_RETURN: float = 0.0445         # 4.45% daily target
MIN_PROFIT_PER_TRADE: float = 0.001         # 0.1% minimum profit after fees
FEE_BUFFER_MULTIPLIER: float = 2.5          # Spread must be 2.5x the round-trip fees

# ── Advanced Risk Parameters ────────────────────────────────────────────────────────────────────
MAX_DRAWDOWN_PCT: float = 0.1               # 10% maximum equity drawdown
DAILY_LOSS_LIMIT: float = 0.05              # 5% maximum daily loss
MAX_LEVERAGE: float = 1.0                   # No leverage (1.0 = spot only)
MIN_TRADE_SIZE: float = 10.0                # $10 minimum trade size
POSITION_TIMEOUT_HOURS: int = 24            # Hours before considering position stale

# ── Market Making Strategy ──────────────────────────────────────────────────────────────────────
# TARGET_SPREAD_PCT: float = 0.001          # 0.1% target spread in calm markets (was 10 bps)
# MAX_SPREAD_PCT: float = 0.005             # 0.5% max spread during volatility (was 50 bps)
DYNAMIC_SPREAD_MULTIPLIER: float = 1.5      # 1.5x market spread for opportunistic trades

# ── Volatility & Danger Detection ───────────────────────────────────────────────────────────────
VOLATILITY_THRESHOLD: float = 0.02          # 2% price move triggers wider spreads
PANIC_THRESHOLD: float = 0.05               # 5% price move triggers emergency shutdown
PANIC_LOOKBACK_WINDOW: int = 60             # Duration in seconds to measure the panic threshold

# ── Market Selection & Filters ──────────────────────────────────────────────────────────────────
QUOTE_CURRENCY: str = "USDT"                # Only select USDT pairs ᴾᴿᴱꝬᴵᴸᵀᴱᴿ
MIN_24H_VOLUME: float = 5000000             # 5M USDT minimum volume ᴾᴿᴱꝬᴵᴸᵀᴱᴿ
MAX_24H_VOLUME: float = 200000000           # 200M USDT maximum volume ᴾᴿᴱꝬᴵᴸᵀᴱᴿ
MIN_COIN_AGE: int = 7                       # Minimum days of trading required ᴾᴿᴱꝬᴵᴸᵀᴱᴿ
MIN_BOOK_DEPTH_USD: float = 1000.0          # Minimum order book depth in USD
MAX_TOP_WALL_SHARE: float = 0.3             # Maximum allowed top order dominance (30%)
MIN_LIQUIDITY_SCORE: float = 50.0           # Minimum score (0-100) to consider a pair
MAX_ACTIVE_PAIRS: int = 10                  # Maximum simultaneous positions

# ── Scoring Engine Weights ──────────────────────────────────────────────────────────────────────
LIQUIDITY: float = 0.40                     # 40% weight in overall scoring 
SPREAD_TIGHTNESS: float = 0.15              # 15% component in Liquidity scoring §ᵁᴮ
ORDER_BOOK_DEPTH: float = 0.15              # 15% component in Liquidity scoring §ᵁᴮ
SLIPPAGE_RESISTANCE: float = 0.10           # 10% component in Liquidity scoring §ᵁᴮ
MARKET: float = 0.30                        # 30% weight in overall scoring 
VOLATILITY_PROFILE: float = 0.15            # 15% component in Market scoring §ᵁᴮ
VOLUME_CONSISTENCY: float = 0.10            # 10% component in Market scoring §ᵁᴮ 
PRICE_STABILITY: float = 0.05               #  5% component in Market scoring §ᵁᴮ
TRADING: float = 0.30                       # 30% weight in overall scoring 
FEE_EFFICIENCY: float = 0.10                # 10% component in Trading scoring §ᵁᴮ 
EXECUTION_SPEED: float = 0.10               # 10% component in Trading scoring §ᵁᴮ 
MARKET_IMPACT: float = 0.10                 # 10% component in Trading scoring §ᵁᴮ
OPPORTUNITY_MOD: float = 0.05               #  5% bonus applied to the overall score

# ── Operational Settings ────────────────────────────────────────────────────────────────────────
LOOP_DELAY: int = 5                         # Seconds to wait between main loop iterations
LOG_LEVEL: str = "DEBUG"                    # DEBUG, INFO, WARNING, ERROR
CACHE_TTL: int = 30                         # Seconds to cache market data

# ── Emergency Settings ──────────────────────────────────────────────────────────────────────────
MAX_API_RETRIES: int = 3                    # Maximum API retry attempts
HEARTBEAT_TIMEOUT: int = 30                 # Seconds before considering system unresponsive
EMERGENCY_TIMEOUT: int = 300                # Seconds to wait after emergency stop

# ── Exchange & Connection Settings ──────────────────────────────────────────────────────────────
EXCHANGE: str = "kucoin"                    # Currently only kucoin is implemented
API_TIMEOUT: int = 10                       # Seconds before API requests time out
    
# ── Email Server Configuration Settings ─────────────────────────────────────────────────────────
ALERT_EMAIL_ENABLED: bool = True            # Set to False to disable email alerts
ALERT_EMAIL_SMTP_SERVER: str = "smtp.hostinger.com"  
ALERT_EMAIL_SMTP_PORT: int = 465
ALERT_EMAIL_ENCRYPT: str = "SSL"
ALERT_EMAIL_RECIPIENT: str = "james@hodlcorp.io"
# !! Sign-in credentials are located in the dotenv file.
    
# ── Data Manager Windows (in ms) ────────────────────────────────────────────────────────────────
DM_TICK_RETENTION_SECONDS: int = 3600
DM_CANDLE_RETENTION_SECONDS: int = 86400

================================================================================
FILE: mm/config/monit/alma
================================================================================
check process alma with pidfile /root/Echelon/valentrix/mm/utils/tickersticker/alma.pid
  start program = "/bin/bash -lc 'nohup /root/Echelon/valentrix/mm/config/bash/alma.sh >/dev/null 2>&1 &'"
    with timeout 60 seconds
  stop program  = "/bin/bash -lc 'kill -TERM $(cat /root/Echelon/valentrix/mm/utils/tickersticker/alma.pid)'"
  working directory "/root/Echelon/valentrix"
  if does not exist then restart

================================================================================
FILE: mm/config/monit/edith
================================================================================
check process edith with pidfile /root/Echelon/valentrix/mm/utils/partition_manager/edith.pid
  start program = "/bin/bash -lc 'nohup /root/Echelon/valentrix/mm/config/bash/edith.sh >/dev/null 2>&1 &'"
    with timeout 60 seconds
  stop program  = "/bin/bash -lc 'kill -TERM $(cat /root/Echelon/valentrix/mm/utils/partition_manager/edith.pid)'"
  if does not exist then start

================================================================================
FILE: mm/config/monit/laurel
================================================================================
check process laurel with pidfile /root/Echelon/valentrix/mm/utils/canary/laurel.pid
  start program = "/bin/bash -lc 'nohup /root/Echelon/valentrix/mm/config/bash/laurel.sh >/dev/null 2>&1 &'"
    with timeout 60 seconds
  stop program  = "/bin/bash -lc 'kill -TERM $(cat /root/Echelon/valentrix/mm/utils/canary/laurel.pid)'"
  if does not exist then start

================================================================================
FILE: mm/config/bash/laurel.sh
================================================================================
#!/usr/bin/env bash 
set -Eeuo pipefail 
umask 077 
export PYTHONUNBUFFERED=1 

cd /root/Echelon/valentrix 

exec /root/Echelon/bin/python3 -u -m mm.utils.canary.laurel \ 
 >> mm/utils/canary/laurel.log 2>&1

================================================================================
FILE: mm/config/bash/edith.sh
================================================================================
#!/usr/bin/env bash
set -Eeuo pipefail
umask 077
export PYTHONUNBUFFERED=1

cd /root/Echelon/valentrix

exec /root/Echelon/bin/python3 -u -m mm.utils.partition_manager.edith \
  >> mm/utils/partition_manager/partition_manager.log 2>&1

================================================================================
FILE: mm/config/bash/alma.sh
================================================================================
#!/usr/bin/env bash
set -Eeuo pipefail
umask 077
export PYTHONUNBUFFERED=1

cd /root/Echelon/valentrix

exec /root/Echelon/bin/python3 -u -m mm.utils.tickersticker.alma \
  >> mm/utils/tickersticker/alma.log 2>&1

================================================================================
FILE: mm/data/state/state.json
================================================================================
{
  "meta": {
    "version": "1.0",
    "start_time": null,
    "cycle_count": 0
  },
  "equity": {},
  "positions": {},
  "open_orders": {},
  "daily_stats": {},
  "risk_metrics": {},
  "last_actions": {}
}

================================================================================
FILE: mm/data/state/sim_state.json
================================================================================
{
  "meta": {
    "version": "1.0",
    "simulation_start": null,
    "total_cycles": 0
  },
  "balances": {
    "USDT": {
      "available": 2500.00,
      "hold": 0.0
    }
  },
  "performance": {
    "starting_capital": 2500.00,
    "current_equity": 2500.00
  },
  "active_orders": [],
  "position_history": {},
  "realism_stats": {},
  "config_overrides": {}
}

================================================================================
FILE: mm/data/secrets/.env
================================================================================
# [520] [741] [8]

#BestProxy.net
PROXY_USERNAME=figidactual
PROXY_PASSWORD=E8D55D5C814605834F9A71D331ED8ED0
PROXY_HOST=100.42.22.242:54311

# KUCOIN
KUCOIN_API=684815c155fba5000107ef4b
KUCOIN_SEC=0bf6af04-b1b0-4ed3-b8c8-d57c121064f0
KUCOIN_PASSPHRASE=syntient01

# Email Server Sign-in Credentials
# All email accounts are receive restricted - outgoing only.
ARI_USR=ariadne@hodlcorp.io
ARI_PWD=#M4rk3t[-]M4k3r^a01
ARI_NAME= Ariadne Lamarr
DRC_USR=drcalvin@hodlcorp.io
DRC_PWD=M4rk3t[-]M4k3r^d02 
DRC_NAME=Dr. Susan Calvin, B.Ot.
GRA_USR=grayson@hodlcorp.io
GRA_PWD=M4rk3t[-]M4k3r^g03 
GRA_NAME=Grayson Moorcock
NAO_USR=naomi@hodlcorp.io
NAO_PWD=M4rk3t[-]M4k3r^n04 
NAO_NAME=Naomi Nagata
ALE_USR=alec@hodlcorp.io
ALE_PWD=M4rk3t[-]M4k3r^a05 
ALE_NAME=Alec Sadler
MAL_USR=mal@hodlcorp.io
MAL_PWD=M4rk3t[-]M4k3r^m06 
MAL_NAME=Malcolm Reynolds
PET_USR=petra@hodlcorp.io
PET_PWD=M4rk3t[-]M4k3r^p07 
PET_NAME=Petra Arkanian
HEL_USR=helen@hodlcorp.io
HEL_PWD=M4rk3t[-]M4k3r^h08 
HEL_NAME=Helen Magnus
VER_USR=verity@hodlcorp.io
VER_PWD=M4rk3t[-]M4k3r^v09 
VER_NAME=Verity Danton
HAR_USR=hari@hodlcorp.io
HAR_PWD=M4rk3t[-]M4k3r^h10 
HAR_NAME=Hari Seldon
JUL_USR=julius@hodlcorp.io 
JUL_PWD=M4rk3t[-]M4k3r^j11 
JUL_NAME=Julius Deane
CHR_USR=chris@hodlcorp.io
CHR_PWD=M4rk3t[-]M4k3r^c12 
CHR_NAME=Christian Wolff
LAU_USR=laurel@hodlcorp.io
LAU_PWD=M4rk3t[-]M4k3r^l13 
LAU_NAME=Laurel Lance
AND_USR=andi@hodlcorp.io
AND_PWD=M4rk3t[-]M4k3r^a14 
AND_NAME=Andi Clarke
EDI_USR=edith@hodlcorp.io
EDI_PWD=M4rk3t[-]M4k3r^e15 
EDI_NAME=Edith Hathaway
ALM_USR=alma@hodlcorp.io
ALM_PWD=M4rk3t[-]M4k3r^a16 
ALM_NAME=Alma Lane
AGN_USR=agnes@hodlcorp.io
AGN_PWD=M4rk3t[-]M4k3r^a17 
AGN_NAME=Agnus Jurati
MAR_USR=marcus@hodlcorp.io
MAR_PWD=M4rk3t[-]M4k3r^m18 
MAR_NAME=Marcus Eaton
WIN_USR=wintermute@hodlcorp.io
WIN_PWD=M4rk3t[-]M4k3r^w19
WIN_NAME=Wintermute
INA_USR=inara@hodlcorp.io
INA_PWD=M4rk3t[-]M4k3r^i20
INA_NAME=Inara Serra
KAR_USR=karin@hodlcorp.io
KAR_PWD=M4rk3t[-]M4k3r^k21
KAR_NAME=K∙A∙R∙I∙N
#ASH_USR=ash@hodlcorp.io
#ASH_PWD=M4rk3t[-]M4k3r^a22
#ASH_NAME=Ash
#QUO_USR=quorra@hodlcorp.io
#QUO_PWD=M4rk3t[-]M4k3r^q23
#QUO_NAME=Quorra
#VIK_USR=viki@hodlcorp.io
#VIK_PWD=M4rk3t[-]M4k3r^v24
#VIK_NAME=V∙I∙K∙I
#LAM_USR=lamar@hodlcorp.io
#LAM_PWD=M4rk3t[-]M4k3r^l25
#LAM_NAME=Lamar Burgess







================================================================================
FILE: mm/utils/tickersticker/alma.pid
================================================================================
3496182

================================================================================
FILE: mm/utils/tickersticker/alma.py
================================================================================
#===================================================================
# 🍁 A R I A N D E           bot version 6.1 file build 20250905.01
#===================================================================
# last update: 2025 | Sept. 5                   Production ready ✅
#===================================================================
# Alma
# mm/utils/tickersticker/alma.py             
#
#🔺 THIS FILE IS MISSION CRITICAL 🔺
#
# Captures market data every 3 seconds and stores to db.
#
# [520] [741] [8]                   
#===================================================================
# 🔰 THE COMMANDER            ✔ PERSISTANT RUNTIME  ✔ MONIT MANAGED
#===================================================================

# 🔸 Standard Library Imports ======================================

import importlib
import smtplib
import ssl
import uuid 
import time
import psycopg2
import os
import logging
import signal
import sys
import atexit
from datetime import datetime
from mm.conn.conn_kucoin import KucoinClient
from mm.utils.helpers.wintermute import update_heartbeat
from mm.utils.helpers.wintermute import now_local  # local tz helper 
from email.message import EmailMessage
from email.utils import formataddr
from zoneinfo import ZoneInfo
    
# 🔸 third-party imports ===========================================

from dotenv import load_dotenv

# 🔸 local application imports =====================================

import mm.config.marcus as marcus

# 🔸 load env for this process =====================================

load_dotenv("mm/data/secrets/.env")

# 🔸 heartbeat tracer logger =======================================

_hb_logger = logging.getLogger("alma_hb")
_hb_logger.setLevel(logging.INFO)
_log_path = "mm/utils/tickersticker/alma_heartbeats.log"
os.makedirs(os.path.dirname(_log_path), exist_ok=True)
if not _hb_logger.handlers:
    _fh = logging.FileHandler(_log_path)
    _fh.setFormatter(logging.Formatter('%(message)s'))
    _hb_logger.addHandler(_fh)

# 🔸 Global shutdown flag ==========================================

shutdown_requested = False

def signal_handler(signum, frame):
    """Handle SIGTERM and SIGINT for graceful shutdown"""
    global shutdown_requested
    print(f"[SHUTDOWN] Received signal {signum}, shutting down gracefully...")
    shutdown_requested = True

signal.signal(signal.SIGTERM, signal_handler)
signal.signal(signal.SIGINT,  signal_handler)

# 🔸 PID support for MONIT =========================================

PID_FILE = "/root/Echelon/valentrix/mm/utils/tickersticker/alma.pid"

def _cleanup_pidfile():
    try:
        if os.path.exists(PID_FILE):
            os.remove(PID_FILE)
    except Exception:
        pass

# 🔸 remove stale pid if dead ======================================

if os.path.exists(PID_FILE):
    try:
        with open(PID_FILE) as f:
            old = f.read().strip()
        if old.isdigit() and not os.path.exists(f"/proc/{old}"):
            os.remove(PID_FILE)
    except Exception:
        pass

# 🔸 write our pid =================================================

try:
    with open(PID_FILE, "w") as f:
        f.write(str(os.getpid()))
except Exception as e:
    print(f"[PID ERROR] {e}", file=sys.stderr)
    sys.exit(1)

atexit.register(_cleanup_pidfile)

DB_NAME = "ariadne"
TABLE_NAME = "tickstick"
INTERVAL = 3

client = KucoinClient()

FIELDS = [
    "symbol", "symbol_name", "buy", "sell", "last", "best_bid_size", "best_ask_size",
    "change_rate", "change_price", "high", "low", "vol", "vol_value",
    "average_price", "taker_fee_rate", "maker_fee_rate", "taker_coefficient", "maker_coefficient"
]

def get_connection():
    """Create PostgreSQL connection"""
    try:
        conn = psycopg2.connect(database=DB_NAME, user="postgres", host="localhost")
        return conn
    except psycopg2.Error as e:
        print(f"[DB ERROR] Failed to connect: {e}")
        sys.exit(1)

def insert_rows(conn, timestamp, tickers):
    """Insert ticker data into PostgreSQL"""
    
    # Get current UTC timestamp
    timestamp = int(datetime.utcnow().timestamp())

    rows = []
    for t in tickers:
        try:
            symbol = t.get("symbol", "")
            if not symbol.endswith("-USDT"):
                continue

            vol_value = float(t.get("volValue", 0.0))
            if not (2_000_000 <= vol_value < 200_000_000):
                continue

            # Map API fields to DB columns
            row = [
                timestamp,
                t.get("symbol"),
                t.get("symbolName"),
                float(t.get("buy", 0)) if t.get("buy") else None,
                float(t.get("sell", 0)) if t.get("sell") else None,
                float(t.get("last", 0)) if t.get("last") else None,
                float(t.get("bestBidSize", 0)) if t.get("bestBidSize") else None,
                float(t.get("bestAskSize", 0)) if t.get("bestAskSize") else None,
                float(t.get("changeRate", 0)) if t.get("changeRate") else None,
                float(t.get("changePrice", 0)) if t.get("changePrice") else None,
                float(t.get("high", 0)) if t.get("high") else None,
                float(t.get("low", 0)) if t.get("low") else None,
                float(t.get("vol", 0)) if t.get("vol") else None,
                float(t.get("volValue", 0)) if t.get("volValue") else None,
                float(t.get("averagePrice", 0)) if t.get("averagePrice") else None,
                float(t.get("takerFeeRate", 0)) if t.get("takerFeeRate") else None,
                float(t.get("makerFeeRate", 0)) if t.get("makerFeeRate") else None,
                float(t.get("takerCoefficient", 0)) if t.get("takerCoefficient") else None,
                float(t.get("makerCoefficient", 0)) if t.get("makerCoefficient") else None
            ]
            
            # Bounds check for numeric overflow
            MAX_VAL = 999999999999
            skip = False
            for i, val in enumerate(row):
                if isinstance(val, (int, float)) and val > MAX_VAL:
                    print(f"[OVERFLOW SKIP] {symbol} field index {i} = {val}")
                    skip = True
                    break

            if not skip:
                rows.append(tuple(row))
        
        except Exception as e:
            print(f"[PARSE ERROR] {t.get('symbol', '?')} → {e}")

    if rows:
        cursor = conn.cursor()
        try:
            placeholders = ",".join(["%s"] * 19)  # 19 columns total
            sql = f"""
            INSERT INTO {TABLE_NAME} 
            (timestamp, symbol, symbol_name, buy, sell, last, best_bid_size, best_ask_size,
             change_rate, change_price, high, low, vol, vol_value, average_price,
             taker_fee_rate, maker_fee_rate, taker_coefficient, maker_coefficient)
            VALUES ({placeholders})
            """
            
            #--- temp debug tracer ---
            for row in rows:
                for i, val in enumerate(row):
                    if isinstance(val, float) and abs(val) >= 1e12:
                        print(f"[DEBUG] Overflow risk → index: {i}, value: {val}")
            #--- end debug tracer ---
            
            cursor.executemany(sql, rows)
            conn.commit()
            return len(rows)
        except psycopg2.Error as e:
            print(f"[INSERT ERROR] {e}")
            conn.rollback()
            return 0
        finally:
            cursor.close()
    return 0

# 🔸 Drop-in Email Sender ==========================================

def send_email(subject: str, status: str, title: str, message: str) -> 